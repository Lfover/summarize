# C++

## 基本语法

> ### 说一说函数重载

#### 1.含义

函数重载是在同一个作用域中，用同一个函数名定义多个函数，同名函数完成相同的工作，但会用不同的参数列表

#### 2.条件

想要构成函数重载，必须要满足函数名相同，作用域相同，且参数列表不同，例如参数的个数，参数类型，参数顺序不同，但是参数的返回值是不影响函数是否构成重载的，还有一种特殊情况是const修饰函数参数是指针或引用也可以构成重载

```c++
void fun(char*)
void fun(const char*)
    
void fun(char&)
void fun(const char&)
```

#### 3.使用

函数重载是在编译期间才能确定函数重载的形式，在运行期间去链接对应的重载函数

#### 4.强制类型转换

函数重载中也存在类型的强制转换，当一个函数没有匹配戴完美的参数列表时，会尝试尝试对参数进行强转匹配，如果强转后也没有匹配的，或是匹配到了多个函数，则编译器会报错（编译器不知道去使用哪一个，就把问题抛出来，让我们解决）

#### 5.为什么C++支持函数重载但是C语言不支持

程序要运行起来，需要经过 预处理，编译，汇编， 链接四个阶段、每一个编译器都有自己的函数名修饰规则，用C语言编译器编译的时候，函数名字的修饰不会改变，而用C++编译器编译后，函数的名字修饰会发生改变，编译器会将函数参数信息添加到修改后的名字当中去，因此在C语言编译器下，即使是不同的参数列表的同名函数，修饰后函数名字也是相同的，无法区分，因此就不支持重载，而C++只要函数参数不同，修饰出来的函数名字也不同，能够区分，也因此支持函数重载 

____

> ### 谈一谈对引用的理解

#### 1.概念

* 语法概念上引用就是给已知的变量取别名，没有独立的空间，和其引用的变量共用一块空间

* 在底层实现上引用实际是有空间的，因为引用是按照指针方式实现的

#### 2.引用的特性

* 引用类型必须和引用实体是同种类型的

* 引用在定义是必须初始化

* 一个变量可以有多个引用

* 一旦引用了一个实体，就不能再引用其他实体了

* 引用不可以引用数组

#### 3.引用和指针的区别

刚刚谈到引用的底层是指针，但是引用和指针还有很多差别

* 引用必须初始化；指针可以不初始化
* 引用的指向不可改变；指针的指向可以改变
* 没有空引用，但是有空指针
* 没有多级引用，但是有多级指针
* sizeof求值不同，引用时引用类型的大小，指针始终是地址空间所占字节数
* 引用比指针使用起来更安全

#### 4.作用

引用可以做参数，也可以做函数返回值，做返回值时，可以节省拷贝，效率更高，但是不要将函数中的临时变量作为引用返回，会导致访问无效数据

#### 5.左值引用&右值引用







> ### 谈一谈对this指针的理解

#### 1.概念

一个类可以有若干个对象，每个对象有自己独立的数据，但是成员函数只有一份供所有对象使用，为了让被调用的成员函数知道处理的数据是属于哪一个对象的，故隐式传递一个指向调用对象的this指针进入成员函数中，this中保存的是对象的地址

#### 2.谁有this指针

所有非静态成员函数包括构造函数和析构函数都有this指针

#### 3.特性

* this指针的类型是`classname *const this`,所以是不可以被修改的
* this指针只能在成员函数的内部使用
* this指针本质上其实是一个成员函数的形参，是对象调用成员函数时， 将对象地址作为实参传递给this形参，所以对象中不存储this指针,因此也不会影响类的大小
* this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递

#### 4.this指针为空

- 当我们调用函数时，如果函数内部不需要使用到`this`,也就是不需要通过`this`指向当前对象并对其进行操作时才可以为空,(当我们在其中什么都不放或者在里面随便打印一个字符串)
- 如果调用的函数需要指向当前对象，并进行操作，则会发生错误（空指针引用）就跟`C`中一样,不能进行空指针的引用

> ### 内联函数知道吧

#### 1.意义

类内定义的函数规模一般较小，系统调用函数过程的时间花费远远大于执行函数体的时间，为了减少时间的开销，C++自动将类体中定义的不包含循环等控制语句的成员函数作为内置函数处理

他的本质就是省去了调用函数的过程，直接将代码嵌入到调用点

#### 2.特点

使用空间换时间的方法，函数调用多少次，代码就会重复多少次，因此代码很长或是包含循环/递归/的函数不适合做内联函数

内联函数知识对编译器的一种建议，编译器会自行决断是否采纳

#### 3.类外定义内联函数

inline函数不建议定义和声明分离，如果分离可能会导致连接错误

#### 4.内联和宏

1. 宏是内联代码的原始实现

2. 内联函数是按表达式的值传递的

3. 内联函数是在 编译阶段 展开的；宏替换是在 预编译阶段 替换的

#### 5.注意

内联函数是在编译阶段确定的，虚函数是在运行时确定的，因此虚函数不能定义成内联函数

release版本下内联函数会展开，debug版本下内联函数不会展开

> ### 说一说内存泄露

#### 1.内存溢出

内存溢出 OOM （out of memory），是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个int,但给它存了long才能存下的数，那就是内存溢出。

#### 2.内存泄露

内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。最终的结果就是导致OOM。
  内存泄漏是指你向系统申请分配内存进行使用(`new`)，可是使用完了以后却不归还(`delete`)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。

#### 3.内存泄露的原因

* 指针重新赋值
* 错误的内存释放
* 返回值的不正确处理
* 内存分配后忘记释放

### 面向对象

在主观世界中，对于我们要研究的实体对象，首先将它和同类相同的行为和属性进行提取，抽象成类；将抽象成的类映射在计算机世界中的类，再根据类实例化得到我们要研究的实体对象

> ###  面向对象

C语言是面向过程的，将完成一件事情细分成多个解题步骤，注重步骤之间的逻辑，通过函数调用来逐步解决问题

> ###  面向过程

C++是面向对象的，将完成一件事情拆分成不同的对象，注重对象之间的交互，通过交互来逐步解决问题

## 类和对象

> ### 对象

客观世界的任何一个事务都可以看成一个对象，对象由属性和行为组成，函数代码保存一份到代码区，数据每个对象独有一份

#### 什么是类

类是对象的抽象，将不同对象进行相同特征的提取，进而形成的类

> ####  class与struct

C++中struct和class的相同点

1.结构体和类一样，可以有成员变量，可以有成员函数，也可以定义`public`,`private`,`protected`数据成员
2.结构体可以从别的结构体继承，也可以被别的结构体继承，亦可以有虚函数
3.结构体定义之后，可以像类一样用结构体名来创建对象
4.c++兼容C语言，所以c++中`struct` 可以当成结构体去使用

C++中struct和class的不同点

1.`class` 的成员默认都是` private` 属性的； `struct` 中的成员默认都是 `public` 属性的。
2.`class` 继承默认是 `private` 继承，而 `struct `继承默认是 `public` 继承。
3.`class`与`struct`内部结构有区别，`struct`只能添加带参的构造函数，不能使用`abstract`和`protected`等修饰符，不能初始化实例字段。
4.`class` 可以使用模板，而 `struct` 不能。
5.`struct`是值类型，`class`是引用类型，因此它们具有所有值类型和引用类型之间的差异。

#### 类的大小

根据 结构体内存对齐规则 计算所有数据成员的大小和

内存对齐原则

* 第一个成员变量与结构体变量偏移量为0的地址处
* 其他成员变量要对齐到对齐数的整数倍处
* 结构体的总大小为最大对齐数的整数倍，结构体与结构体之间也要对齐
* 如果嵌套了结构体，嵌套结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍

#### 空类大小

在vs下，空类大小占1字节，因为使用该类进行实例化时，它必须在内存中占用一定空间，否则，无法使用这些实例，至于占用多少内存，由编译器决定

#### 虚函数的空类大小

因为类需要存储一个指向虚函数表的指针，因此32位机器下是4字节，64位机器下是8字节

> ###  构造函数

#### 1.概念

* 函数名与类名相同，创建类对象时，由编译器自动调用

* 保证每一个数据成员都有一个合适的初始值

* 在对象生命周期内只调用一次

#### 2.功能

初始化对象，而不是给对象创建空间

#### 3.特性

* 函数名与类名相同
* 没有返回值
* 构造函数可以重载
* 实例化对象时，由编译器自动调用

#### 4.构造方式

4.1体内构造

函数体内初始化数据，数据只能初始化一次，但是可以赋值多次

4.2初始化列表

每个成员只能在初始化列表中出现一次

引用成员变量， const成员变量，无默认构造参数的类对象都必须在初始化列表位置进行初始化

#### 5.形式

默认构造函数

没有参数的构造函数，自动生成的，无需显示声明定义，若显式声明定义，则不会自动再生成一个

含参构造函数

可以给构造函数以默认的参数，但是给参数的顺序只能时从右往左赋值

* 构造函数不能是虚函数

  调用虚函数需要虚函数表指针，虚函数表指针需要构造函数初始化，便造成了 生成自己的前提是自己存在 的悖论现象

#### 6.类型转换

隐式类型转换（implicit)

显示类型转换（explicit)

> ### 拷贝构造函数

1.特点

只有一个形参，类类型对象的常引用（const A& a),必须是引用，否则无限递归调用拷贝构造函数

如果没有显示定义拷贝构造函数，系统会自动生成默认拷贝构造函数

2.浅拷贝问题

当初始化的是 char* 类型的指针时，如果不自定义拷贝构造函数，会产生浅拷贝的现象，仅仅是改变了指针的指向，并没有给本对象成员数据分配内存







1. 自我介绍时添加上平时是如何学习技术的 

   

   #### 项目的介绍：实现了哪些功能 每个功能是如何实现的

   实现了在浏览器中查看全部试题信息，当我点击一个试题的时候，可以跳转到对应的一个试题，在里面进行代码编写，编写完成以后点击submit提交，提交的代码就会传到服务器中去编译运行，服务器编译运行之后，会将运行的结果返还给浏览器中去显示

####  为什么选择文件存储题目而不是选择数据库 

其实文件存储还是数据库都是可以的，只不过我这个项目是一个简单的模拟力扣的项目，cpp访问数据库会比较复杂，使用文件存储更加简单方便

#### 为什么使用进程程序替换而不是开辟一个新线程处理？ 

我在编译的时候是用了进程程序替换，将原进程替换成了一个G++进程，用来进行编译，为了保证每个代码都独立的编译，多个请求之间互不影响，所以若干个请求都需要使用G++去替换，如果是多线程的话，他们使用的是一个进程，就会混乱

#### 进程虚拟地址空间 

早期的内存管理机制是一个计算机如果要运行程序，就直接运行在内存上，也就是程序访问的内存地址都是实际的物理内存地址，当一个计算机想要运行多个程序的时候，必须要保证这些程序用到的内存量要小于实际的物理内存，这样会导致

* 恶意程序会直接修改进程中的内存数据
* 效率低，如果剩下的内存不够用，系统只能将运行的程序暂时拷贝到硬盘上，释放处空间才能使用
* 运行地址不确定，当剩余的空间满足程序要求后，会在剩余的空间中随机分配一段连续的空间给程序使用，我们没有办法确认其地址

传统的管理机制有这么多问题，因此在后面的发展中为了解决这些问题，想到了虚拟地址空间

每创建一个进程，操作系统就会默认为该进程分配一个4G的虚拟进程空间地址，虚拟地址空间对应物理地址空间，但是进程只能访问自己虚拟地址空间里的数据，这样就解决的地址隔离，我们每创建一个进程，就相当于创建了一个PCB，PCB会对应一个task_struct结构体，这个结构体指向一块虚拟地址空间，虚拟地址空间被由下至上分为代码区，已初始化数据区，未初始化数据区，堆区，共享区，栈区，等，这个虚拟地址空间会对应一个页表，页表才是去映射正真的物理内存

#### 进程与线程区别？ 

进程是操作系统分配资源的基本单位，线程是任务调度的基本单位

1.一个进程至少有一个线程，一个进程可以运行多个线程，多个线程之间共享数据

2.进程有自己独立的地址空间，代码，程序上下文等，进程之间的切换开销会比较大，而线程是共享一个进程的地址空间的，多个线程公用进程的堆和方法区

3.各个线程之间切换工作的负担要比进程小得多，所以线程也被称为轻量级进程

#### 线程特有的、不共享的资源？ 

每个线程有自己的id,寄存器组，栈，错误返回码，线程的信号屏蔽码，线程的优先级等

#### get post  区别

1.url,get的参数url是可见的，post的url参数是不可见的

2.数据传输：get通过拼接url进行传递参数，post通过body体传输参数

3.缓存性：get请求时可以缓存的，但是post请求是不能缓存的

4.传输数据大小：get一般传输的大小不超过2k-4k,post传输的数据大熊啊可以设定的无限大

5.数据包：get是浏览器把header和data一起发送出去，服务器响应200，而post是浏览器先发动heaer，然后服务器响应100，之后浏览器在发送data，服务器响应200

6.安全性 原则上post比get更加安全，因为url是不可见的

#### 请求与响应是哪个协议的？http是哪一层的？TCPIP协议分层有哪几层？有哪些请求方法？

http协议，http协议在应用层,tcp在传输层，ip在网络层

![img](https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180810112625596-2103906128.png)

#### auto推导类型的判断是处于哪个时期的？

在编译时期进行推导，范围for 自定义类型很繁琐的时候使用

#### 编译具体分为哪几个阶段？具体工作内容？

分为预处理阶段，编译阶段，汇编阶段，链接阶段

预处理：头文件展开，宏替换，去掉所有注释的代码，执行预处理指令

编译阶段：词法分析，语法分析，语义分析，优化，转汇编

汇编阶段

连接阶段

#### gdb常用命令？

r(run)执行程序

start:执行到main函数停住

n(next)下一条指令，不进入函数

s(step)进入函数

c执行到下一个断点停住

q退出调试

b（break)设置断点

info b 删除断点



#### 多线程调试查看线程的命令？

info threads 

#### grep命令的作用？find? whereis?

搜索文本，并把匹配的打印出来

#### vector自动扩容的倍数？迭代器失效？

c++1.5倍，g++是2倍

#### 堆的概念？堆的实现方式？

#### 二叉搜索树的概念？二叉平衡树和二叉搜索树的区别？

#### 查看端口号的命令？

netstat -an 显示出电脑中所有被打开的端口列表. netstat -ano 显示出所有占用端口的列表.

#### 进程间通信的方式？管道的介绍？管道破裂的信号？命名管道与匿名管道的名字表现在什么上面的？

#### vector和list的区别？各自优缺点？

#### map的底层数据结构?平衡二叉树和红黑树的区别？

map的底层实现是红黑树，之所以叫平衡二叉树们就是因为它每一个结点的左右子树高度只差不会超过1，一直维持一个平衡因子，但是由于它维持这个平衡因子，所以当插入或删除一个结点的时候，就需要旋转来维持平衡，效率比较低

红黑树也是一颗平衡树，但是有不同的性质

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长

#### unordered_map的底层数据结构？

哈希表，

#### TCP的三次握手与四次挥手的具体内容、拥塞控制的四个算法？

tcp三次握手是由客户端先给服务端发送一个SYN数据包，这是客户端的状态变成了

#### TCP和UDP属于哪一层？IP协议属于哪一层？DNS协议？

tcp，udp在传输层，ip在网络层，dns协议在应用层

网络数据在传输过程中五元组信息，任何一个需要在网络当中传输的数据，都会具有五元组信息，否则网络不会给转发

{源端口，目的端口，源IP，目的IP，协议}

#### 说一下http状态码

1xx  指示信息，表示请求已接收，继续处理

2xx  成功 表示请求已被成功接收，解析，接受

* 200 客户端请求成功
* 201 请求已被成功处理，并且创建了新的资源

3xx  重定向，一般表示要完成请求必须进行更近一步的操作

* 301 永久重定向，表示资源已经永久移动到了另一个位置
* 304 表示客户端可以使用以前请求的结果，不需要再次请求

4xx  客户端错误，一般是请求有语法错误或请求无法实现

* 400 语法无效，服务器无法理解该请求
* 401 请求未经授权

* 403 指的是服务端有能力处理该请求，但是拒绝授权访问
* 404 请求资源不存在，比如资源被删除了，错误的url

5xx  服务器端错误，服务器未能实现合法的请求

* 500 服务器发生了不可预期的错误
* 502 表示作为网关或代理角色的服务器，从上游服务器中接收到的响应是无效的
* 503服务器当前不能处理客户端请求，一段时间后回复正常
* 504 表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应

#### 说一下计算机的补码，为什么会有补码

采用补码可以简化**计算机硬件电路设计的复杂度 **。 对于有符号数，内存要区分符号位和数值位，要是能把符号位和数值位等同起来，让它们一起参与运算，不再加以区分，只用加法器就可以同时实现加法和减法运算，这样硬件电路就变得简单了。

#### 补码是怎么计算的（二进制，八进制，十六进制）

二进制：符号位不变，其余位按位取反后，+1

八进制：

十六进制：FFFF-正数代表的十六进制+1

#### 大小端了解吗，大小端分别在哪里应用 

这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

小端就是：低字节序放在低地址中，高字节序放在高地址中

大端：低字节序放在高地址，高字节序放在低地址

小端字节序通常应用在主机字节序，大端主要应用在网络字节序

¨          #define ntohs(n)     //16位数据类型网络字节顺序到主机字节顺序的转换

¨          #define htons(n)     //16位数据类型主机字节顺序到网络字节顺序的转换

¨          #define ntohl(n)      //32位数据类型网络字节顺序到主机字节顺序的转换

¨          #define htonl(n)      //32位数据类型主机字节顺序到网络字节顺序的转换


#### 6.网络io有哪些，如何使用 ，io复用 （select poll epoll)

io复用的意义: 是用于提升**效率，单**个进程可以同时监听多个网络连接 IO

首先io的几个经典的模型分为阻塞IO， 非阻塞IO， 信号驱动io, 异步IO， 多路转接IO

1.阻塞IO：

发起IO调用，如果IO条件不满足则一直等待，直到条件符合

2.非阻塞IO ：

发起IO调用，如果条件不满足则直接报错返回，执行其他的指令，然后再次发起IO调用，如果条件不满足继续报错返回，直到调用时发现条件满足，之后执行数据拷贝，然后调用返回

3.信号驱动IO ：

自定义IO信号，如果IO条件具备则发送IO信号，收到信号后则打断其他操作进行信号处理，执行IO操作进行数据拷贝，结束后调用返回

4.异步IO：

CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。

在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。

因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。

多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。

由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。

另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。

5.多路IO复用

5.1作用：可以监控多个文件描述符，当文件描述符当中有事件产生的时候，就会通知调用者

select poll epoll

##### select 

```c++
int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);
```

select模型对大量描述符进行几种事件监控，让用户能够仅仅针对事件就绪的描述符进行操作，对就绪事件的判断主要有以下几个标准：
  1、可读事件：接收缓冲区中数据大小大于等于低水位标记（默认一个字节）。
  2、可写事件：发送缓冲区中空闲空间的大小大于等于低水位标记（默认一个字节）。
  3、异常事件：描述符是否发生了某些异常。

1.实际上每个事件都对应一个位图，将某个事件集合中描述符的位置置为1用于标记用户关心该描述符的某些事件

2.将这些集合拷贝到内核空间进行监控，对这个位图中的所有描述符进行遍历判断，判断事件是否就绪

3.如果有某个文件描述符就绪了了用户关心的事件， 则会返回给用户结果，返回的时候分别从各个事件中将没有就绪的文件描述符对应的位置置为0， 返回给用户三个表示就绪文件描述符的集合

4.用户通过遍历拿到的文件描述符集合，来判断哪些文件描述符就绪了哪些事件，之后进行操作

```
//fd_set是一个结构体，结构体内部是一个数组，数组元素是long类型，但是它不是按照数组方式使用的，而是按照位图方式使用的
fd_set readfds;//定义文件描述符集合，这个文件描述符集合的名字叫做readfds
//将文件描述符集合中的全部比特位都置为0
FD_ZERO(&readfds);
//将关心的事件描述符放进事件集合中
FD_SET(0, &readfds);
FD_SET(1, &readfds);
//第一个参数是nfds,是监控的最大文件描述符的数值+1，例如我监控的最大文件描述符是8 ，那nfds就是9
//第二个参数是读事件集合
//第三个参数是写事件集合
//第四个参数是异常事件集合
select(2, &readfds, NULL, NULL, NULL);
```

操作fd_set的接口



#### 7.多线程如何实现同步的

#### 8.C11使用了哪些

#### 9.STL容器使用了哪些

##### 关联式容器 set/ mutil_set/map/multi_map

底层是二叉树

value模式

set自动排序，不允许值重复，元素不可修改

mutil_set自动排序，允许值重复

key_value模式

map自动排序，k可以重复但是v不允许重复

multi_map依据K自动排序，K允许重复，V也允许重复

##### 序列式容器vector/list /deque/array

vector底层是动态数组，元素逻辑上是连续的，物理上也是连续的，支持索引随机访问，插入元素可能会导致元素后移，如果插入元素的数量大于他的容量，会进行重新分配内存，重新分配数组，将内容拷贝进去，非常耗时,vs下1.5倍，g++默认2倍，迭代器失效时指迭代器地城的指针使用的时一块倍销毁的空间，并且是用来这个非法空间，导致程序崩溃，可能使迭代器失效的原因，insert,resize,push_back(因为如果我插入的元素已经超过了数组的原有大小，然后就会冲洗分配内存，释放渊薮空间，自然迭代器就失效了),erase

list底层是双向链表，不支持随机访问，支持随机插入和删除，插入市迭代器不会失效，但是删除时会导致当前迭代器失效

deque底层是双端队列，双开口，可以在首尾两端进行插入和删除，不是真正意义上的连续，而是由一段连续的空间通过中控区来管理，map中控区是一对连续的动态数组，数据元素是指针，指向实际存储数据的buffer缓冲区，buffer缓冲区是一段连续的一维数组，deque作为stack 和queue的底层容器，扩容无需搬移数据，内存使用率高

array静态数组

##### 无序容器unordered_set/unordered-multiset/unordered_map/unordered_multimap

unordered_set不允许重复

unordered_multiset允许重复

unordered_map中的K不允许重复

unordered_multimap中的K允许重复

##### 其他容器string

string 底层是char*,底层拷贝问题存在浅拷贝，仅仅拷贝了目标对象的地址，可能会导致非法访问，重复释放内存

深拷贝，开辟一块新的内存，将目标对象拷贝进来

写实拷贝，引用计数，给资源的使用者的数量进行计数，将资源的计数给成1，每当出现拷贝该资源时，引用计数+1，如果出现修改资源内容时，再重新开辟空间，将内容拷贝进去，提供给修改者区修改内容，写时拷贝只是将拷贝的时间延迟

#### 10.说一说vector

vector的底层实现是动态数组，在逻辑上

#### 12.remove_if的使用

第一个参数时初始位置，第二个参数是末尾位置，第三个参数是想要移动的元素，ermove_if的作用就是将第三个参数移动到数组的末尾，不能实现真正的删除元素，通常搭配erase使用

#### 在浏览器下输入一个url会发生什么

解析url地址

由DNS协议进行解析，解析出来对应的ip地址

* 解析过程：1.查找浏览器缓存，浏览器一般会缓存DNS记录一段时间，如果有缓存，直接返回ip，没有下一步
* 2.查找系统缓存，在浏览器缓存中找不到ip以后，浏览器会进行系统调用，查找本机的hosts文件，如果找到了，返回Ip,没有下一步
* 3.查找路由器缓存，路由器一般有自己的DNS缓存，将前面的请求发送给路由器，如果查找到了，返回IP没有下一步
* 4.递归查询，上面都没有找到ip的话，lsp的DNS服务器就会进行递归查询（就是如果主机询问的本地域名服务器不知道背查询的域名的ip地址，，那么本地域名服务器以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步查询）
* 5.迭代查询：本地域名服务器向根域名服务器查询一般用的都是迭代查询（就是当根域名服务器收到本地域名服务器发出的查询请求报文后，告诉本地域名服务器下一步应该查询哪一个域名服务器，然后本地域名服务器自己去查询）

ip地址和服务端默认发80端口建立tcp连接，（tcp三次握手）

http协议是建立在tcp/ip协议之上的，tcp三次握手建立完成之后，http就可以进行正常的请求和响应了，浏览器通过http协议发送请求

服务端接收请求

服务器响应

tcp断开连接

浏览器解析资源

渲染页面

#### 编译运行好的结果是怎么返回给前端的

用到了httplib中定义好的请求与响应的结构，通过把运行好的结果写入文件，然后再从文件中读取结果的方式

#### json cpp 的作用 ？ 

一个json对象，用来将源代码和测试用例放在一起构成一个结构，提交给编译运行模块

####  boost库用了哪些函数？

使用了split切割函数

#### 如何获取到用户提交的代码？用的什么请求？

用了http请求

#### 日志是如何实现的？

#### body是如何取出来的？

如何解析的

C++：

#### 面向对象的三个特性？

封装继承多态

#### 继承中的菱形继承？虚基类？虚基类表概念及作用？

#### 多态的理解？多态的条件？多态是用什么实现的？虚函数？动态多态与静态多态？

#### 函数重载与函数重写的区别？

#### 空类的大小？

目前VS下是1

#### 为什么要有内存对齐？

Linux：

#### 进程地址空间分哪些段？每个段的作用？代码段存储的代码的语言类型？哪些系统调用操作共享内存？栈区的大小多少？查栈大小的命令？递归与栈之间的关系？栈帧？

#### 虚拟地址空间中页的大小？

#### 查看进程的Linux命令？grep的作用？

数据结构：

#### vector底层数据结构？删除增加的效率差为什么？迭代器失效的原理？erase函数的返回值？

#### unordered_map底层数据结构？哈希碰撞的概念及处理方法？

#### N路归并排序

计算机网络：

#### HTTP是位于哪一层的？HTTP方法？PUT方法的作用？POST方法和GET方法的区别？状态码？

#### HTTPS有了解吗？

#### TCP/UDP是哪一层的？DNS是哪一层的？DNS的传输层使用的协议？

#### TCP的拥塞控制？

算法题：

#### 设计题

8G的数据存储在磁盘上 需要排序

内存只有 2G

如何对这8G的数据进行排序？

归并

8G -> 8个1G的文件中

1G的内容进行排序 -> 8次

8 - 4 - 2 - 1

####  合并K个升序链表



#### 说一下什么是面向对象编程

首先谈起面向对象编程，就要先了解什么是面向对象，我们和面向过程一起理解，从概念上来说，面向过程是将完成一件事情细分成多个解题步骤，注重步骤之间的逻辑，通过函数调用来逐步解决问题，而面向对象是将完成一件事拆分成多个对象，注重对象之间的交互，通过交互来逐步解决问题，举个例子，把大象放进冰箱，如果是面向过程的话，就是执行打开冰箱的代码，执行把大象放进冰箱的方法，执行把冰箱门关上的方法，那面向对象就是两个对象，一个人对象，一个冰箱对象（人.打开冰箱 ，人.放大象进冰箱， 人. 关上冰箱门）（冰箱.冰大象）

可以看出面向过程的优点就是性能比面向对象高，因为类调用需要实例化，开销比较大，比较消耗资源，缺点就是没有面向对象好维护， 易复用，易扩展，面向对象的优点就是易维护，易复用，易扩展，面向对象有封装，继承，多态的特性，可以设计出低耦合的系统，是系统更加灵活，更加易于维护，缺点是性能比面向对象低

三大特性

封装

封装，就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分

继承

继承是面向对象设计中代码复用的重要手段，在原有的类上进行拓展，新增功能，产生的类被称为派生类，

继承方式有单继承，多继承，菱形继承

父子间赋值的转换 父类指针，引用， 对象可以指向子类对象，子类指针可以指向父类对象， 父类对象不可赋值给子类对象



## 数据库

安装mariadb

 查看当前机器是否拥有mariadb

```
rpm -qa | grep mariadb
```

![image-20220423131306419](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220423131306419.png)

```
yum list | grep mariadb
```

![image-20220423131654583](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220423131654583.png)

安装

```
yum install mariadb-server
yum install mriadb
yum install mariadb-devel
```

启动

```
service mariadb start
```

停止

```
service mariadb stop
```

重启

```
service mariadb restart
```

