# C++

## 基本语法

> ### 说一说函数重载

#### 1.含义

函数重载是在同一个作用域中，用同一个函数名定义多个函数，同名函数完成相同的工作，但会用不同的参数列表

#### 2.条件

想要构成函数重载，必须要满足函数名相同，作用域相同，且参数列表不同，例如参数的个数，参数类型，参数顺序不同，但是参数的返回值是不影响函数是否构成重载的，还有一种特殊情况是const修饰函数参数是指针或引用也可以构成重载

```c++
void fun(char*)
void fun(const char*)
    
void fun(char&)
void fun(const char&)
```

#### 3.使用

函数重载是在编译期间才能确定函数重载的形式，在运行期间去链接对应的重载函数

#### 4.强制类型转换

函数重载中也存在类型的强制转换，当一个函数没有匹配戴完美的参数列表时，会尝试尝试对参数进行强转匹配，如果强转后也没有匹配的，或是匹配到了多个函数，则编译器会报错（编译器不知道去使用哪一个，就把问题抛出来，让我们解决）

#### 5.为什么C++支持函数重载但是C语言不支持

程序要运行起来，需要经过 预处理，编译，汇编， 链接四个阶段、每一个编译器都有自己的函数名修饰规则，用C语言编译器编译的时候，函数名字的修饰不会改变，而用C++编译器编译后，函数的名字修饰会发生改变，编译器会将函数参数信息添加到修改后的名字当中去，因此在C语言编译器下，即使是不同的参数列表的同名函数，修饰后函数名字也是相同的，无法区分，因此就不支持重载，而C++只要函数参数不同，修饰出来的函数名字也不同，能够区分，也因此支持函数重载 

____

> ### 谈一谈对引用的理解

#### 1.概念

* 语法概念上引用就是给已知的变量取别名，没有独立的空间，和其引用的变量共用一块空间

* 在底层实现上引用实际是有空间的，因为引用是按照指针方式实现的

#### 2.引用的特性

* 引用类型必须和引用实体是同种类型的

* 引用在定义是必须初始化

* 一个变量可以有多个引用

* 一旦引用了一个实体，就不能再引用其他实体了

* 引用不可以引用数组

#### 3.引用和指针的区别

刚刚谈到引用的底层是指针，但是引用和指针还有很多差别

* 引用必须初始化；指针可以不初始化
* 引用的指向不可改变；指针的指向可以改变
* 没有空引用，但是有空指针
* 没有多级引用，但是有多级指针
* sizeof求值不同，引用时引用类型的大小，指针始终是地址空间所占字节数
* 引用比指针使用起来更安全

#### 4.作用

引用可以做参数，也可以做函数返回值，做返回值时，可以节省拷贝，效率更高，但是不要将函数中的临时变量作为引用返回，会导致访问无效数据

#### 5.左值引用&右值引用







> ### 谈一谈对this指针的理解

#### 1.概念

一个类可以有若干个对象，每个对象有自己独立的数据，但是成员函数只有一份供所有对象使用，为了让被调用的成员函数知道处理的数据是属于哪一个对象的，故隐式传递一个指向调用对象的this指针进入成员函数中，this中保存的是对象的地址

#### 2.谁有this指针

所有非静态成员函数包括构造函数和析构函数都有this指针

#### 3.特性

* this指针的类型是`classname *const this`,所以是不可以被修改的
* this指针只能在成员函数的内部使用
* this指针本质上其实是一个成员函数的形参，是对象调用成员函数时， 将对象地址作为实参传递给this形参，所以对象中不存储this指针,因此也不会影响类的大小
* this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递

#### 4.this指针为空

- 当我们调用函数时，如果函数内部不需要使用到`this`,也就是不需要通过`this`指向当前对象并对其进行操作时才可以为空,(当我们在其中什么都不放或者在里面随便打印一个字符串)
- 如果调用的函数需要指向当前对象，并进行操作，则会发生错误（空指针引用）就跟`C`中一样,不能进行空指针的引用

> ### 内联函数知道吧

#### 1.意义

类内定义的函数规模一般较小，系统调用函数过程的时间花费远远大于执行函数体的时间，为了减少时间的开销，C++自动将类体中定义的不包含循环等控制语句的成员函数作为内置函数处理

他的本质就是省去了调用函数的过程，直接将代码嵌入到调用点

#### 2.特点

使用空间换时间的方法，函数调用多少次，代码就会重复多少次，因此代码很长或是包含循环/递归/的函数不适合做内联函数

内联函数知识对编译器的一种建议，编译器会自行决断是否采纳

#### 3.类外定义内联函数

inline函数不建议定义和声明分离，如果分离可能会导致连接错误

#### 4.内联和宏

1. 宏是内联代码的原始实现

2. 内联函数是按表达式的值传递的

3. 内联函数是在 编译阶段 展开的；宏替换是在 预编译阶段 替换的

#### 5.注意

内联函数是在编译阶段确定的，虚函数是在运行时确定的，因此虚函数不能定义成内联函数

release版本下内联函数会展开，debug版本下内联函数不会展开

> ### 说一说内存泄露

#### 1.内存溢出

内存溢出 OOM （out of memory），是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个int,但给它存了long才能存下的数，那就是内存溢出。

#### 2.内存泄露

内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。最终的结果就是导致OOM。
  内存泄漏是指你向系统申请分配内存进行使用(`new`)，可是使用完了以后却不归还(`delete`)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。

#### 3.内存泄露的原因

* 指针重新赋值
* 错误的内存释放
* 返回值的不正确处理
* 内存分配后忘记释放

### 面向对象

在主观世界中，对于我们要研究的实体对象，首先将它和同类相同的行为和属性进行提取，抽象成类；将抽象成的类映射在计算机世界中的类，再根据类实例化得到我们要研究的实体对象

> ###  面向对象

C语言是面向过程的，将完成一件事情细分成多个解题步骤，注重步骤之间的逻辑，通过函数调用来逐步解决问题

> ###  面向过程

C++是面向对象的，将完成一件事情拆分成不同的对象，注重对象之间的交互，通过交互来逐步解决问题

## 类和对象

> ### 对象

客观世界的任何一个事务都可以看成一个对象，对象由属性和行为组成，函数代码保存一份到代码区，数据每个对象独有一份

#### 什么是类

类是对象的抽象，将不同对象进行相同特征的提取，进而形成的类

> ####  class与struct

C++中struct和class的相同点

1.结构体和类一样，可以有成员变量，可以有成员函数，也可以定义`public`,`private`,`protected`数据成员
2.结构体可以从别的结构体继承，也可以被别的结构体继承，亦可以有虚函数
3.结构体定义之后，可以像类一样用结构体名来创建对象
4.c++兼容C语言，所以c++中`struct` 可以当成结构体去使用

C++中struct和class的不同点

1.`class` 的成员默认都是` private` 属性的； `struct` 中的成员默认都是 `public` 属性的。
2.`class` 继承默认是 `private` 继承，而 `struct `继承默认是 `public` 继承。
3.`class`与`struct`内部结构有区别，`struct`只能添加带参的构造函数，不能使用`abstract`和`protected`等修饰符，不能初始化实例字段。
4.`class` 可以使用模板，而 `struct` 不能。
5.`struct`是值类型，`class`是引用类型，因此它们具有所有值类型和引用类型之间的差异。

#### 类的大小

根据 结构体内存对齐规则 计算所有数据成员的大小和

内存对齐原则

* 第一个成员变量与结构体变量偏移量为0的地址处
* 其他成员变量要对齐到对齐数的整数倍处
* 结构体的总大小为最大对齐数的整数倍，结构体与结构体之间也要对齐
* 如果嵌套了结构体，嵌套结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍

#### 空类大小

在vs下，空类大小占1字节，因为使用该类进行实例化时，它必须在内存中占用一定空间，否则，无法使用这些实例，至于占用多少内存，由编译器决定

#### 虚函数的空类大小

因为类需要存储一个指向虚函数表的指针，因此32位机器下是4字节，64位机器下是8字节

> ###  构造函数

#### 1.概念

* 函数名与类名相同，创建类对象时，由编译器自动调用

* 保证每一个数据成员都有一个合适的初始值

* 在对象生命周期内只调用一次

#### 2.功能

初始化对象，而不是给对象创建空间

#### 3.特性

* 函数名与类名相同
* 没有返回值
* 构造函数可以重载
* 实例化对象时，由编译器自动调用

#### 4.构造方式

4.1体内构造

函数体内初始化数据，数据只能初始化一次，但是可以赋值多次

4.2初始化列表

每个成员只能在初始化列表中出现一次

引用成员变量， const成员变量，无默认构造参数的类对象都必须在初始化列表位置进行初始化

#### 5.形式

默认构造函数

没有参数的构造函数，自动生成的，无需显示声明定义，若显式声明定义，则不会自动再生成一个

含参构造函数

可以给构造函数以默认的参数，但是给参数的顺序只能时从右往左赋值

* 构造函数不能是虚函数

  调用虚函数需要虚函数表指针，虚函数表指针需要构造函数初始化，便造成了 生成自己的前提是自己存在 的悖论现象

#### 6.类型转换

隐式类型转换（implicit)

显示类型转换（explicit)

> ### 拷贝构造函数

1.特点

只有一个形参，类类型对象的常引用（const A& a),必须是引用，否则无限递归调用拷贝构造函数

如果没有显示定义拷贝构造函数，系统会自动生成默认拷贝构造函数

2.浅拷贝问题

当初始化的是 char* 类型的指针时，如果不自定义拷贝构造函数，会产生浅拷贝的现象，仅仅是改变了指针的指向，并没有给本对象成员数据分配内存







1. 自我介绍时添加上平时是如何学习技术的 

   

   #### 项目的介绍：实现了哪些功能 每个功能是如何实现的

   实现了在浏览器中查看全部试题信息，当我点击一个试题的时候，可以跳转到对应的一个试题，在里面进行代码编写，编写完成以后点击submit提交，提交的代码就会传到服务器中去编译运行，服务器编译运行之后，会将运行的结果返还给浏览器中去显示

####  为什么选择文件存储题目而不是选择数据库 

其实文件存储还是数据库都是可以的，只不过我这个项目是一个简单的模拟力扣的项目，cpp访问数据库会比较复杂，使用文件存储更加简单方便

#### 为什么使用进程程序替换而不是开辟一个新线程处理？ 

我在编译的时候是用了进程程序替换，将原进程替换成了一个G++进程，用来进行编译，为了保证每个代码都独立的编译，多个请求之间互不影响，所以若干个请求都需要使用G++去替换，如果是多线程的话，他们使用的是一个进程，就会混乱

#### 进程虚拟地址空间 

早期的内存管理机制是一个计算机如果要运行程序，就直接运行在内存上，也就是程序访问的内存地址都是实际的物理内存地址，当一个计算机想要运行多个程序的时候，必须要保证这些程序用到的内存量要小于实际的物理内存，这样会导致

* 恶意程序会直接修改进程中的内存数据
* 效率低，如果剩下的内存不够用，系统只能将运行的程序暂时拷贝到硬盘上，释放处空间才能使用
* 运行地址不确定，当剩余的空间满足程序要求后，会在剩余的空间中随机分配一段连续的空间给程序使用，我们没有办法确认其地址

传统的管理机制有这么多问题，因此在后面的发展中为了解决这些问题，想到了虚拟地址空间

每创建一个进程，操作系统就会默认为该进程分配一个4G的虚拟进程空间地址，虚拟地址空间对应物理地址空间，但是进程只能访问自己虚拟地址空间里的数据，这样就解决的地址隔离，我们每创建一个进程，就相当于创建了一个PCB，PCB会对应一个task_struct结构体，这个结构体指向一块虚拟地址空间，虚拟地址空间被由下至上分为代码区，已初始化数据区，未初始化数据区，堆区，共享区，栈区，等，这个虚拟地址空间会对应一个页表，页表才是去映射正真的物理内存

#### 进程与线程区别？ 

进程是操作系统分配资源的基本单位，线程是任务调度的基本单位

1.一个进程至少有一个线程，一个进程可以运行多个线程，多个线程之间共享数据

2.进程有自己独立的地址空间，代码，程序上下文等，进程之间的切换开销会比较大，而线程是共享一个进程的地址空间的，多个线程公用进程的堆和方法区

3.各个线程之间切换工作的负担要比进程小得多，所以线程也被称为轻量级进程

#### 线程特有的、不共享的资源？ 

每个线程有自己的id,寄存器组，栈，错误返回码，线程的信号屏蔽码，线程的优先级等

#### get post  区别

1.url,get的参数url是可见的，post的url参数是不可见的

2.数据传输：get通过拼接url进行传递参数，post通过body体传输参数

3.缓存性：get请求时可以缓存的，但是post请求是不能缓存的

4.传输数据大小：get一般传输的大小不超过2k-4k,post传输的数据大熊啊可以设定的无限大

5.数据包：get是浏览器把header和data一起发送出去，服务器响应200，而post是浏览器先发动heaer，然后服务器响应100，之后浏览器在发送data，服务器响应200

6.安全性 原则上post比get更加安全，因为url是不可见的

#### 请求与响应是哪个协议的？http是哪一层的？TCPIP协议分层有哪几层？有哪些请求方法？

http协议，http协议在应用层,tcp在传输层，ip在网络层

![img](https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180810112625596-2103906128.png)

#### auto推导类型的判断是处于哪个时期的？

在编译时期进行推导，范围for 自定义类型很繁琐的时候使用

1. 编译具体分为哪几个阶段？具体工作内容？

   #### gdb常用命令？

   r(run)执行程序

   start:执行到main函数停住

   n(next)下一条指令，不进入函数

   s(step)进入函数

   c执行到下一个断点停住

   q退出调试

   b（break)设置断点

   info b 删除断点

   

   #### 多线程调试查看线程的命令？

   info threads 

   #### grep命令的作用？

搜索文本，并把匹配的打印出来

#### vector自动扩容的倍数？迭代器失效？

c++1.5倍，g++是2倍

#### 堆的概念？堆的实现方式？

#### 二叉搜索树的概念？二叉平衡树和二叉搜索树的区别？

#### 查看端口号的命令？

netstat -an 显示出电脑中所有被打开的端口列表. netstat -ano 显示出所有占用端口的列表.

#### 进程间通信的方式？管道的介绍？管道破裂的信号？命名管道与匿名管道的名字表现在什么上面的？

#### vector和list的区别？各自优缺点？

#### map的底层数据结构?平衡二叉树和红黑树的区别？

#### unordered_map的底层数据结构？

#### 哈希表

#### TCP的三次握手与四次挥手的具体内容、拥塞控制的四个算法？

#### TCP和UDP属于哪一层？IP协议属于哪一层？DNS协议？



网络数据在传输过程中五元组信息，任何一个需要在网络当中传输的数据，都会具有五元组信息，否则网络不会给转发

{源端口，目的端口，源IP，目的IP，协议}