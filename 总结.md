# C++

#### 说一说函数重载

1.含义

函数重载是在同一个作用域中，用同一个函数名定义多个函数，同名函数完成相同的工作，但会用不同的参数列表

2.条件

想要构成函数重载，必须要满足函数名相同，作用域相同，且参数列表不同，例如参数的个数，参数类型，参数顺序不同，但是参数的返回值是不影响函数是否构成重载的，还有一种特殊情况是const修饰函数参数是指针或引用也可以构成重载

```c++
void fun(char*)
void fun(const char*)
    
void fun(char&)
void fun(const char&)
```

3.使用

函数重载是在编译期间才能确定函数重载的形式，在运行期间去链接对应的重载函数

#### 强制类型转换

函数重载中也存在类型的强制转换，当一个函数没有匹配戴完美的参数列表时，会尝试尝试对参数进行强转匹配，如果强转后也没有匹配的，或是匹配到了多个函数，则编译器会报错（编译器不知道去使用哪一个，就把问题抛出来，让我们解决）

#### 为什么C++支持函数重载但是C语言不支持

程序要运行起来，需要经过 预处理，编译，汇编， 链接四个阶段、每一个编译器都有自己的函数名修饰规则，用C语言编译器编译的时候，函数名字的修饰不会改变，而用C++编译器编译后，函数的名字修饰会发生改变，编译器会将函数参数信息添加到修改后的名字当中去，因此在C语言编译器下，即使是不同的参数列表的同名函数，修饰后函数名字也是相同的，无法区分，因此就不支持重载，而C++只要函数参数不同，修饰出来的函数名字也不同，能够区分，也因此支持函数重载 

____

#### 谈一谈对引用的理解

1.概念

* 语法概念上引用就是给已知的变量取别名，没有独立的空间，和其引用的变量共用一块空间

* 在底层实现上引用实际是有空间的，因为引用是按照指针方式实现的

2.引用的特性

* 引用类型必须和引用实体是同种类型的

* 引用在定义是必须初始化

* 一个变量可以有多个引用

* 一旦引用了一个实体，就不能再引用其他实体了

* 引用不可以引用数组

3.引用和指针的区别

刚刚谈到引用的底层是指针，只是使用的寄存器不太一样，但是引用和指针还有很多差别

* 引用必须初始化；指针可以不初始化
* 引用的指向不可改变；指针的指向可以改变
* 没有空引用，但是有空指针
* 没有多级引用，但是有多级指针
* sizeof求值不同，引用时引用类型的大小，指针始终是地址空间所占字节数
* 引用比指针使用起来更安全
* 引用不可以引用数组

4.作用

引用可以做参数，也可以做函数返回值，做返回值时，可以节省拷贝，效率更高，代替指针更加安全，但是不要将函数中的临时变量作为引用返回，会导致访问无效数据

5.左值引用&右值引用

* 右值：非字面常量（用双引号括起的字符串除外），可出现在赋值等号右边的实体

* 左值：可被引用的数据对象，例如：变量、数组元素、结构成员变量，可出现在赋值等号左边的实体

* 右值引用：只可以引用右值，使用&&

* 左值引用：只可以引用左值，使用&

  

#### 谈一谈对this指针的理解

1.概念

一个类可以有若干个对象，每个对象有自己独立的数据，但是成员函数只有一份供所有对象使用，为了让被调用的成员函数知道处理的数据是属于哪一个对象的，故隐式传递一个指向调用对象的this指针进入成员函数中，this中保存的是对象的地址

2.谁有this指针

所有非静态成员函数包括构造函数和析构函数都有this指针

3.特性

* this指针的类型是`classname *const this`,所以是不可以被修改的
* this指针只能在成员函数的内部使用
* this指针本质上其实是一个成员函数的形参，是对象调用成员函数时， 将对象地址作为实参传递给this形参，所以对象中不存储this指针,因此也不会影响类的大小
* this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递

4.this指针为空

- 当我们调用函数时，如果函数内部不需要使用到`this`,也就是不需要通过`this`指向当前对象并对其进行操作时才可以为空,(当我们在其中什么都不放或者在里面随便打印一个字符串)
- 如果调用的函数需要指向当前对象，并进行操作，则会发生错误（空指针引用）就跟`C`中一样,不能进行空指针的引用

#### 内联函数知道吧

1.意义

类内定义的函数规模一般较小，系统调用函数过程的时间花费远远大于执行函数体的时间，为了减少时间的开销，C++自动将类体中定义的不包含循环等控制语句的成员函数作为内置函数处理

他的本质就是省去了调用函数的过程，直接将代码嵌入到调用点

2.特点

使用空间换时间的方法，函数调用多少次，代码就会重复多少次，因此代码很长或是包含循环/递归/的函数不适合做内联函数

内联函数知识对编译器的一种建议，编译器会自行决断是否采纳

3.类外定义内联函数

inline函数不建议定义和声明分离，如果分离可能会导致连接错误

4.内联和宏

1. 宏是内联代码的原始实现
2. 内联函数是按表达式的值传递的
3. 内联函数是在 编译阶段 展开的；宏替换是在 预编译阶段 替换的
4. 内联函数会做类型检查，而宏不会

5.注意

内联函数是在编译阶段确定的，虚函数是在运行时确定的，因此虚函数不能定义成内联函数

release版本下内联函数会展开，debug版本下内联函数不会展开

#### 说一说内存泄露

1.内存溢出

内存溢出 OOM （out of memory），是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个int,但给它存了long才能存下的数，那就是内存溢出。

2.内存泄露

内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。最终的结果就是导致OOM。
  内存泄漏是指你向系统申请分配内存进行使用(`new`)，可是使用完了以后却不归还(`delete`)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。

3.内存泄露的原因

* 指针重新赋值
* 错误的内存释放
* 返回值的不正确处理
* 内存分配后忘记释放

4.解决办法

* 使用的时候要记得指针的长度
* malloc的时候要确定在哪里free
* 堆指针赋值的时候应该注意被赋值指针需不需要释放
* 动态分配的内存指针最好不要再次赋值
* 在c++中应该优先考虑使用智能指针

#### 面向对象

在主观世界中，对于我们要研究的实体对象，首先将它和同类相同的行为和属性进行提取，抽象成类；将抽象成的类映射在计算机世界中的类，再根据类实例化得到我们要研究的实体对象

面向对象

C语言是面向过程的，将完成一件事情细分成多个解题步骤，注重步骤之间的逻辑，通过函数调用来逐步解决问题

面向过程

C++是面向对象的，将完成一件事情拆分成不同的对象，注重对象之间的交互，通过交互来逐步解决问题

#### 说一下什么是面向对象编程

首先谈起面向对象编程，就要先了解什么是面向对象，我们和面向过程一起理解，从概念上来说，面向过程是将完成一件事情细分成多个解题步骤，注重步骤之间的逻辑，通过函数调用来逐步解决问题，而面向对象是将完成一件事拆分成多个对象，注重对象之间的交互，通过交互来逐步解决问题，举个例子，把大象放进冰箱，如果是面向过程的话，就是执行打开冰箱的代码，执行把大象放进冰箱的方法，执行把冰箱门关上的方法，那面向对象就是两个对象，一个人对象，一个冰箱对象（人.打开冰箱 ，人.放大象进冰箱， 人. 关上冰箱门）（冰箱.冰大象）

可以看出面向过程的优点就是性能比面向对象高，因为类调用需要实例化，开销比较大，比较消耗资源，缺点就是没有面向对象好维护， 易复用，易扩展，面向对象的优点就是易维护，易复用，易扩展，面向对象有封装，继承，多态的特性，可以设计出低耦合的系统，是系统更加灵活，更加易于维护，缺点是性能比面向对象低

#### 三大特性

封装

封装，就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分

继承

继承是面向对象设计中代码复用的重要手段，在原有的类上进行拓展，新增功能，产生的类被称为派生类，一个对象直接使用另一个对象的属性和方法

继承方式有单继承，多继承，菱形继承

父子间赋值的转换 父类指针，引用， 对象可以指向子类对象，子类指针可以指向父类对象， 父类对象不可赋值给子类对象
优点：

1.减少重复的代码。

2.继承是多态的前提。

3.继承增加了类的耦合性。
缺点：

1.继承在编译时刻就定义了，无法在运行时刻改变父类继承的实现；
2.父类通常至少定义了子类的部分行为，父类的改变都可能影响子类的行为；
3.如果继承下来的子类不适合解决新问题，父类必须重写或替换，那么这种依赖关系就限制了灵活性，最终限制了复用性。

虚继承：为了解决多重继承中的二义性问题，它维护了一张虚基类表。

多态

C++中有两种多态，称为 动多态（运行期多态） 和 静多态（编译期多态） ，而 静多态主要通过模板来实现，宏也是实现静多态的一种途径 。 动多态在C++中是通过虚函数实现的 ，即在基类中存在一些接口（一般为纯虚函数），子类必须重载这些接口。这样通过使用基类的指针或者引用指向子类的对象，就可以实现调用子类对应的函数的功能。动多态的函数调用机制是执行期才能进行确定，所以它是动态的。
接口的多种不同实现方式即为多态。
优点：

1.大大提高了代码的可复用性；

 2.提高了了代码的可维护性，可扩充性；
 缺点：

1）易读性比较不好，调试比较困难

2）模板只能定义在.h文件中，当工程大了之后，编译时间十分的变态

对象不包含虚函数表，只有虚指针，类才包含虚函数表，派生类会生成一个兼容基类的虚函数表。

**虚函数表：**

**（1）** 原始基类的虚函数表

![img](https://pic1.zhimg.com/80/v2-b15a8f1c0a4c86914c88d9ad2c803c34_720w.jpg)

上图是原始基类的对象，可以看到虚指针在地址的最前面，指向基类的虚函数表（假设基类定义了3个虚函数）

（2） 单继承时的虚函数（无重写基类虚函数）

假设现在派生类继承基类，并且重新定义了3个虚函数，派生类会自己产生一个兼容基类虚函数表的属于自己的虚函数表。

![img](https://pic2.zhimg.com/80/v2-23afa2bc4d0114d54103d0c65019dc5d_720w.jpg)

Derive Class继承了Base Class中的3个虚函数，准确说是该函数的实体地址被拷贝到Derive Class的虚函数列表中，派生新增的虚函数置于虚函数列表后面，并按声明顺序摆放。

**（3）** 单继承时的虚函数（重写基类虚函数）

现在派生类重写基类的x函数，可以看到这个派生类构建自己的虚函数表的时候，修改了base::x()这一项，指向了自己的虚函数。

![img](https://pic2.zhimg.com/80/v2-ac49d7bc3c3afc11d4965e0c6c94dc25_720w.jpg)

**（4）** 多重继承时的虚函数

这个派生类多重继承了两个基类base1，base2，因此它有两个虚函数表。

![img](https://pic1.zhimg.com/80/v2-73fbd72874be64b37705cce2946dc930_720w.jpg)

**隐藏：**

除了重载和重写，在C++中还有一个“隐藏”。隐藏是通过继承，在派生类中创建于父类同名函数实现。具体规则如下：

（1） 如果派生类的某个函数与父类的某个同名，但参数不同。此时，无论是否有virtual关键字，父类函数将被隐藏。

（2） 如果派生类的函数与父类的函数同名，并且参数也相同，但父类该函数没有virtual关键字。此时父类的该函数在派生类中将被隐藏。

#### 类和对象

1.对象

客观世界的任何一个事务都可以看成一个对象，对象由属性和行为组成，函数代码保存一份到代码区，数据每个对象独有一份

2.什么是类

类是对象的抽象，将不同对象进行相同特征的提取，进而形成的类

3.类的大小

根据 结构体内存对齐规则 计算所有数据成员的大小和

内存对齐原则

* 第一个成员变量与结构体变量偏移量为0的地址处
* 其他成员变量要对齐到对齐数的整数倍处
* 结构体的总大小为最大对齐数的整数倍，结构体与结构体之间也要对齐
* 如果嵌套了结构体，嵌套结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍

4.空类大小

在vs下，空类大小占1字节，因为使用该类进行实例化时，它必须在内存中占用一定空间，否则，无法使用这些实例，至于占用多少内存，由编译器决定

5.虚函数的空类大小

因为类需要存储一个指向虚函数表的指针，因此32位机器下是4字节，64位机器下是8字节

##### 抽象类

* 无法实例化对象
* 若子类没有重写抽象类的纯虚函数，子类也是抽象类

##### 虚基类

* 当一个父类被声明为虚基类的时候，其数据在派生类中只存一份
* 每一个虚拟继承的累都有一个虚基类表指针，指向虚基类表，虚基类表中包含一个地址偏移量，用于寻求找到虚基类的成员变量
* 虚基类表指针可以继承	

##### 关键词修饰

const :

const数据成员：该数据必须在初始化列表初始化，初始化之后不允许修改

const成员函数：const修饰this指针，所以不允许修改数据成员的值

static: 可以通过类和对象访问

static数据成员：必须在类外进行初始化，所有对象共享着一份数据

static成员函数：无法访问任何非静态成员，没有this指针，不依赖对象

#### 模板

* 1.模板概念

c++中运行以泛型的方式定义类和对象，数据类型以一个字符代替，在定义前使用template < class T>

* 2.函数模板

2.1 用途：定义一个通用类型的完成某功能的函数

2.2 参数确定期：编译阶段，编译器根据传入的实参类型来推演生成对应的代码以供使用

2.3匹配原则：函数模板与具体类型函数同时出现，优先匹配具体类型的函数

函数模板与具体类型的函数同时出现，调用出为显示调用，则优先匹配模板

* 3.类模板

定义一个通用类型的类，在实例化模板类时，需要显示传递参数

* 4.非类型模板参数

模板列表中使用常量作为模板参数

不允许（浮点数，类对象，字符串）作为非类型模板参数的参数

* 5.模板特化

5.1概念

针对特殊数据类型进行特殊化的实现方式

5.2 函数模板特化

例如比较大小的函数模板，但是处理不了字符串大小比较，步骤为：有函数模板；写一个特殊场景的具体函数，在刚函数前加template<>;函数名后加<具体类型>，也可以使用具体函数来取代函数模板特化

5.3 类模板特化

全特化：全部模板参数为指定的具体类型

偏特化：部分模板参数指定为具体类型

* 分离编译

1.概念

如果项目由若干个源文件组成，每个源文件单独生成目标文件，再将所有目标文件链接成可执行文件的过程称为分离编译

2.有模板的分离

若定义和实现分离，且调用与实现也分离，可能导致模板代码不实例化的情况出现，导致连接失败

3.无模板的分离

如果main源文件中没有某个函数的实现，连接器就回去其他目标文件中寻找

* 优缺点

优点：代码复用，节约资源，增强灵活性

缺点：模板代码一旦出错，很难定位，模板实例化会增加编译时间



####  class与struct的相同与不同

C++中struct和class的相同点

1.结构体和类一样，可以有成员变量，可以有成员函数，也可以定义`public`,`private`,`protected`数据成员
2.结构体可以从别的结构体继承，也可以被别的结构体继承，亦可以有虚函数
3.结构体定义之后，可以像类一样用结构体名来创建对象
4.c++兼容C语言，所以c++中`struct` 可以当成结构体去使用

C++中struct和class的不同点

1.`class` 的成员默认都是` private` 属性的； `struct` 中的成员默认都是 `public` 属性的。
2.`class` 继承默认是 `private` 继承，而 `struct `继承默认是 `public` 继承。
3.`class`与`struct`内部结构有区别，`struct`只能添加带参的构造函数，不能使用`abstract`和`protected`等修饰符，不能初始化实例字段。
4.`class` 可以使用模板，而 `struct` 不能。
5.`struct`是值类型，`class`是引用类型，因此它们具有所有值类型和引用类型之间的差异。

#### 堆区和栈区的区别

![img](https://upload-images.jianshu.io/upload_images/1609713-eaa6e0729938352f.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

1.堆存放动态分配的对象，即在程序运行时动态分配的对象，比如new出来的对象，其生命周期有程序控制

2.栈用来保存定义在函数内的非static对象，如局部变量，仅在其定义的程序块运行时才存在

3.栈区是向低地址扩展的，是一块连续的内存区域，栈顶 的地址和最大容量是预先规定好的，大小是在进程分配时决定的，一般不超过10M

4.堆区是向高地址扩展的，是不连续的内存区域，会手动分配，大小不确定，会大一点

5.栈区内存由系统自动分配，一般速度较快，但是无法控制，堆区由new分配，一般速度较慢，容易产生内存碎片

#### 函数重载与函数重写的区别？

**函数重载**(Overload) :同类同名不同参方法
发生在同一个类中。
方法名相同、参数列表不相同。
和返回值没有关系。
**函数重写**（Override）：在[子类](https://so.csdn.net/so/search?q=子类&spm=1001.2101.3001.7020)中和父类相同声明的方法
发生在子父类中，必须有继承关系。
返回值类型相同、方法名、参数列表相同。
子父类中的方法一模一样

#### malloc和new的区别和联系，new除了分配内存还有什么作用

**malloc/free**：库函数

malloc函数相内存申请一块连续可用的空间，如果开辟成功则返回一个指向该空间的void*类型的子还真，所以需要对其进行强制类型转换，称为我们想要的类型

如果开辟失败返回Null,所以一定要堆malloc的返回值进行检查

free用来释放动态开辟的内存，而不是释放指针，且只能释放一次，如果释放多次会出现错误，但是释放空指针例外，释放空指针相当于什么也没做

**new/delete**：操作符

new的步骤调用operator new函数，调用响应的构造函数来构造对象，并传入初值，对象构造完成后，返回一个指向该对象的指针

delete步骤是调用对象的析构函数，调用operator delete函数释放内存空间

**区别**

* 开辟位置

严格上说，malloc动态开辟的内存在堆区，new开辟的叫自用存储区，但是如果补充在new操作符，c++编译器一般使用堆来实现自用存储，new可以不为对象分配内存

* 重载

new,delete是操作符，可以重载，只能在c++中使用，malloc,free是函数，可以覆盖，c,c++中都可以使用

* 是否调用构造函数与析构函数

new可以调用对象的构造函数，对用的delete调用析构函数，mallc仅仅分配内存，free仅仅回收内存，不执行构造函数和析构函数

* 是否需要指定大小

malloc需要显示指出开辟的内存的大小，new不需要指定，编译器会自当计算

* 返回值类型

new返回的是某种类型的指针，malloc返回的是void指针，new比malloc更安全；new内存分配失败是，会抛出bac_alloc异常，不会返回null,malloc开辟内存失败会返回null指针，所以需要判断

不能 malloc/free主要是为了兼容C，malloc/free不能用在动态类上，理论上说malloc申请的内存是可以通过delete释放的，但是一般不这样写 ，因为不能保证每一个c++的运行是都能正常

#### typedef和define有什么区别

* 用法不同

typedef用来定义一种数据类型的别名，增强程序的可读性，define主要用来定义常量，以及书写复杂使用频繁的宏

* 执行时间不同

typedef是编译过程的一部分，有类型检查功能，define是宏定义，是编译的部分，其发生在编译之前，只是简单是字符串替换，不进行类型检查

* 作用域不同

typedef有作用域限定，define不受作用域约束，只要在define声明后应用都是正确的

* 对指针的操作不同

typedef定义的是语句，因为要在句尾加上;,而define不是语句，不要加；

#### 一个函数调用的具体过程



```c++
int main()
{
	...
	d = fun(a, b, c);
	cout << d << endl;
	...
	return 0;
}
```

main:

1.首先是参数压栈，压栈的顺序是从右到左，即c, b, a

2.保存调用函数处的下一条指令,即cout

3.跳转到fun函数，以上三步都是在main函数中进行的

fun:

4.移动ebp和esp形成新的栈帧结构

5.压栈形成临时变量并执行相关操作

6.return一个值

7.出栈

8.恢复main函数的栈帧结构

9.返回mian函数

main:

10.走main函数的逻辑

#### 智能指针的原理

1 智能指针的作用

智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源

2 智能指针的种类

   shared_ptr、unique_ptr、weak_ptr、auto_ptr 

(1) shared_ptr 

        实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。 
    
     1) 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针；
    
     2) 每次创建类的新对象时，初始化指针并将引用计数置为1；
    
     3) 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；
    
     4) 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；
    
     5) 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。

(2) unique_ptr 

unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。

(3) weak_ptr 

weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。

(4) auto_ptr 

 auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，auto_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个auto_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空。

#### 四种类型转换

C语言支持类型转换，为什么c++还要引入娶她类型转换，C语言的转换风格很简单，但是又不少缺点，

1.转换太过随意，可以在任意类型之间进行转换，可以把const转成非const ,把一个基类对象的指针，转换成派生类对象的指针，这些转换值之间的差距时非常大的

2.c风格的转换没有统一的关键字和标识符，对于大醒系统，做代码排查时容易遗漏和忽略



c++对类型转换做了细分，提供四种不同类型的转换，支持不同的需求

类型转换有了统一的标识符，利于代码的排查和检视



1.satic_cast:类层次结构中基类和派生类之间指针或引用的转换

2.dynamic_cast:必须时指针，继承关系的类型指针，派生类之间转换才可以用

3.const_cast：常量指针转换成非常量指针

4.reinterpret_cast:为了映射到完全不同的意思

#### 为什么要使用delete[]

#### estent C的作用

extern "C"的主要作用就是为了能够**正确实现C++代码调用其他C语言代码**。 加上extern "C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。 由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern "C"就是其中的一个策略。

####  构造函数

1.概念

* 函数名与类名相同，创建类对象时，由编译器自动调用

* 保证每一个数据成员都有一个合适的初始值

* 在对象生命周期内只调用一次

2.功能

初始化对象，而不是给对象创建空间

3.特性

* 函数名与类名相同
* 没有返回值
* 构造函数可以重载
* 实例化对象时，由编译器自动调用

4.构造方式

4.1体内构造

函数体内初始化数据，数据只能初始化一次，但是可以赋值多次

4.2初始化列表

每个成员只能在初始化列表中出现一次

引用成员变量， const成员变量，无默认构造参数的类对象都必须在初始化列表位置进行初始化

5.形式

默认构造函数

没有参数的构造函数，自动生成的，无需显示声明定义，若显式声明定义，则不会自动再生成一个

含参构造函数

可以给构造函数以默认的参数，但是给参数的顺序只能时从右往左赋值

* 构造函数不能是虚函数

  调用虚函数需要虚函数表指针，虚函数表指针需要构造函数初始化，便造成了 生成自己的前提是自己存在 的悖论现象

6.类型转换

隐式类型转换（implicit)

显示类型转换（explicit)

#### 拷贝构造函数

1.特点

只有一个形参，类类型对象的常引用（const A& a),必须是引用，否则无限递归调用拷贝构造函数

如果没有显示定义拷贝构造函数，系统会自动生成默认拷贝构造函数

2.浅拷贝问题

当初始化的是 char* 类型的指针时，如果不自定义拷贝构造函数，会产生浅拷贝的现象，仅仅是改变了指针的指向，并没有给本对象成员数据分配内存

#### auto推导类型的判断是处于哪个时期的？

在编译时期进行推导，范围for 自定义类型很繁琐的时候使用

#### 编译具体分为哪几个阶段？具体工作内容？

![img](https://img-blog.csdn.net/20170305111720349?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRHlsYW5Eb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

分为预处理阶段，编译阶段，汇编阶段，链接阶段

1.预处理：头文件展开，宏替换，去掉所有注释的代码，执行预处理指令

2.编译阶段：

词法分析阶段：读入源程序，对构成源程序的字符流进行扫描和分解，识别出单词，

语法分析阶段：机器通过词法分析，将单词序列分解成不同的语法短语，确定整个输入串能够构成语法上正确的程序。

语义分析阶段：检查源程序上有没有语义错误，在代码生成阶段收集类型信息

中间代码生成阶段：在进行了上述的语法分析和语义分析阶段的工作之后,有的编译程序将源程序变成一种内部表示形式

代码优化：这一阶段的任务是对前一阶段产生的中间代码进行变换或进行改造,目的是使生成的目标代码更为高效,即省时间和省空间

目标代码生成：这一阶段的任务是把中间代码变换成特定机器上的绝对指令代码或可重定位的指令代码或汇编指令代码

汇编阶段

连接阶段

#### C11使用了哪些

1.智能指针

2.右值引用，

3.auto ：在编译时期对变量进行类型推导，避免使用模板

4.decltype:auto可以声明一个变量，decltype可以从一个变量或表达式中获取类型

5.nullptr空指针：为了解决原来c++中NULL的二义性问题，NULL实际代表的时0

6.序列for循环：可以用于遍历数组，容器，string,以继有begin,end函数定义的序列

7.lambda表达式：创建并定义匿名对象，简化变成工作，[函数对象参数] (操作符重载函数参数)->返回值类型{函数体}

#### 继承中的菱形继承？虚基类？虚基类表概念及作用？

菱形继承是一个子类继承自两个父类，这两个父类又同时继承自一个父类，虚基类就是用virtual修饰的声明的父类

虚基类表的作用是帮助编译器找到该类中的虚基类中各个成员变量在内存布局中的位置。 虚基类表中的值是偏移值，即：各个虚基类的成员变量在子类中的内存布局中相对于虚函数指针的偏移值。

#### 多态是怎么实现的

要理解多态，首先要了解程序的执行过程：
1. 源程序通过编译生成的可执行文件是放在外存中的，程序中的变量和函数只有逻辑地址。
2. 程序运行时，程序从外存加载到内存，为程序中的变量和函数分配物理内存单元，使其具备物理地址。物理地址与变量名、函数名建立一一映射，物理地址与逻辑地址建立映射的过程称为绑定。
3. 程序的加载分为静态加载和动态加载。
多态性具体体现在运行和编译两个方面：
运行时多态，又称动态多态或者晚绑定，通过虚函数、抽象类、接口来实现；
编译时多态，又称静态多态或者早绑定，通过运算符重载、函数重载、模板来实现。
4. 程序加载完毕，并分配了运行所需的所有资源后，程序开始运行。

实现运行时的多态需要满足3个条件：
1. 基类与派生类之间为public继承
2. 基类函数声明为虚函数
3. 通过基类指针或引用调用虚函数
派生类的虚函数重写或者覆盖了基类的同名虚函数。

非类的成员函数，类的静态成员函数，类的构造函数不能为虚函数，但析构函数可以为虚函数。
将基类的析构函数定义为虚函数后，当通过基类指针删除指向派生类的动态对象时，系统会调用相应的类的析构函数，如果不将基类的析构函数定义为虚函数，则只会调用基类的析构函数。

抽象类：
含有纯虚函数的类称为抽象类，或者成为抽象基类。
抽象类不能实例化，但是可以声明抽象类的指针或引用。通过抽象类的指针或引用指向不同的子类对象。

#### 虚函数的原理，在虚函数后面加=0是什么

纯虚函数

#### 抽象类的特点

含有纯虚函数的类被称为抽象类。抽象类只能作为派生类的基类，不能定义对象，但可以定义指针。在派生类实现该纯虚函数后，定义抽象类对象的指针，并指向或引用子类对象。

1）在定义纯虚函数时，不能定义虚函数的实现部分；

2）在没有重新定义这种纯虚函数之前，是不能调用这种函数的。

　　抽象类的唯一用途是为派生类提供基类，纯虚函数的作用是作为派生类中的成员函数的基础，并实现动态多态性。继承于抽象类的派生类如果不能实现基类中所有的纯虚函数，那么这个派生类也就成了抽象类。因为它继承了基类的抽象函数，只要含有纯虚函数的类就是抽象类。纯虚函数已经在抽象类中定义了这个方法的声明，其它类中只能按照这个接口去实现。

接口和抽象类的区别

1）C++中我们一般说的接口，表示对外提供的方法，提供给外部调用。是沟通外部跟内部的桥梁。也是以类的形式提供的，但一般该类只具有成员函数，不具有数据成员；

2）抽象类可以既包含数据成员又包含方法。

虚表和虚函数存放在内存中的哪里

#### 空类的大小？

目前VS下是1

#### 为什么要有内存对齐？

1、平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

2、性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，对于访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

#### 内存管理

_CrtMemBlockHeader结构体 存放了 申请的内存块 的信息，这个结构体地址就存在malloc返回的指针上面，堆上面申请的内存块以 双向链表 的方式组织在一起，系统真正分配给你的内存大小为：申请大小 + 32字节，多余32字节用于存储申请的内存的额外信息：
	28字节信息：前后内存块指针和文件路径等，位于用户申请内存之前
	4字节char型数组：用于检测是否越界，位于用户申请内存之后

为什么系统调用可以使用到共享内存

#### 栈的大小，栈使用的大小与什么有关

#### 哈希是用什么实现的,哈希碰撞

直接定址法：去关键字的某个先行函数为散列地址

除留余数法：设散列表中允许的地址数为m，去一个不大于m的,接近m的质数

闭散列：线性探测，二次探测

开散列

# STL



#### vector自动扩容的倍数？迭代器失效？

c++1.5倍，g++是2倍

#### 堆的概念？堆的实现方式？

#### 二叉搜索树的概念？二叉平衡树和二叉搜索树的区别？

#### vector和list的区别？各自优缺点？

#### list用在什么场合

#### map的底层数据结构?平衡二叉树和红黑树的区别？

map的底层实现是红黑树，之所以叫平衡二叉树们就是因为它每一个结点的左右子树高度只差不会超过1，一直维持一个平衡因子，但是由于它维持这个平衡因子，所以当插入或删除一个结点的时候，就需要旋转来维持平衡，效率比较低

红黑树也是一颗平衡树，但是有不同的性质

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长

#### 红黑树的原理

#### unordered_map的底层数据结构？

哈希表，



#### 9.STL容器使用了哪些

* 关联式容器 set/ mutil_set/map/multi_map

底层是二叉树

value模式

set自动排序，不允许值重复，元素不可修改

mutil_set自动排序，允许值重复

key_value模式

map自动排序，k可以重复但是v不允许重复

multi_map依据K自动排序，K允许重复，V也允许重复

* 序列式容器vector/list /deque/array

vector底层是动态数组，元素逻辑上是连续的，物理上也是连续的，支持索引随机访问，插入元素可能会导致元素后移，如果插入元素的数量大于他的容量，会进行重新分配内存，重新分配数组，将内容拷贝进去，非常耗时,vs下1.5倍，g++默认2倍，迭代器失效时指迭代器地城的指针使用的时一块倍销毁的空间，并且是用来这个非法空间，导致程序崩溃，可能使迭代器失效的原因，insert,resize,push_back(因为如果我插入的元素已经超过了数组的原有大小，然后就会冲洗分配内存，释放渊薮空间，自然迭代器就失效了),erase

list底层是双向链表，不支持随机访问，支持随机插入和删除，插入市迭代器不会失效，但是删除时会导致当前迭代器失效

deque底层是双端队列，双开口，可以在首尾两端进行插入和删除，不是真正意义上的连续，而是由一段连续的空间通过中控区来管理，map中控区是一对连续的动态数组，数据元素是指针，指向实际存储数据的buffer缓冲区，buffer缓冲区是一段连续的一维数组，deque作为stack 和queue的底层容器，扩容无需搬移数据，内存使用率高

array静态数组

* 无序容器unordered_set/unordered-multiset/unordered_map/unordered_multimap

unordered_set不允许重复

unordered_multiset允许重复

unordered_map中的K不允许重复

unordered_multimap中的K允许重复

* 其他容器string

string 底层是char*,底层拷贝问题存在浅拷贝，仅仅拷贝了目标对象的地址，可能会导致非法访问，重复释放内存

深拷贝，开辟一块新的内存，将目标对象拷贝进来

写实拷贝，引用计数，给资源的使用者的数量进行计数，将资源的计数给成1，每当出现拷贝该资源时，引用计数+1，如果出现修改资源内容时，再重新开辟空间，将内容拷贝进去，提供给修改者区修改内容，写时拷贝只是将拷贝的时间延迟

#### 10.说一说vector

vector的底层实现是动态数组，在逻辑上

#### 12.remove_if的使用

第一个参数时初始位置，第二个参数是末尾位置，第三个参数是想要移动的元素，ermove_if的作用就是将第三个参数移动到数组的末尾，不能实现真正的删除元素，通常搭配erase使用

#### vector底层数据结构？删除增加的效率差为什么？迭代器失效的原理？erase函数的返回值？

#### unordered_map底层数据结构？哈希碰撞的概念及处理方法？



# Linux

#### 说一下有哪些方法可以运行进程

#### 进程虚拟地址空间 

早期的内存管理机制是一个计算机如果要运行程序，就直接运行在内存上，也就是程序访问的内存地址都是实际的物理内存地址，当一个计算机想要运行多个程序的时候，必须要保证这些程序用到的内存量要小于实际的物理内存，这样会导致

* 恶意程序会直接修改进程中的内存数据
* 效率低，如果剩下的内存不够用，系统只能将运行的程序暂时拷贝到硬盘上，释放处空间才能使用
* 运行地址不确定，当剩余的空间满足程序要求后，会在剩余的空间中随机分配一段连续的空间给程序使用，我们没有办法确认其地址

传统的管理机制有这么多问题，因此在后面的发展中为了解决这些问题，想到了虚拟地址空间

每创建一个进程，操作系统就会默认为该进程分配一个4G的虚拟进程空间地址，虚拟地址空间对应物理地址空间，但是进程只能访问自己虚拟地址空间里的数据，这样就解决的地址隔离，我们每创建一个进程，就相当于创建了一个PCB，PCB会对应一个task_struct结构体，这个结构体指向一块虚拟地址空间，虚拟地址空间被由下至上分为代码区，已初始化数据区，未初始化数据区，堆区，共享区，栈区，等，这个虚拟地址空间会对应一个页表，页表才是去映射正真的物理内存

#### 进程地址空间分哪些段？每个段的作用？代码段存储的代码的语言类型？哪些系统调用操作共享内存？栈区的大小多少？查栈大小的命令？递归与栈之间的关系？栈帧？

#### 虚拟地址空间中页的大小？

#### 查看进程的Linux命令？grep的作用？

#### 进程等待函数

wait

waitpid

#### 进程与线程区别？ 

进程是操作系统分配资源的基本单位，线程是任务调度的基本单位

1.一个进程至少有一个线程，一个进程可以运行多个线程，多个线程之间共享数据

2.进程有自己独立的地址空间，代码，程序上下文等，进程之间的切换开销会比较大，而线程是共享一个进程的地址空间的，多个线程公用进程的堆和方法区

3.各个线程之间切换工作的负担要比进程小得多，所以线程也被称为轻量级进程

#### 线程特有的、不共享的资源？ 共享的东西？

每个线程有自己的id,寄存器组，栈，错误返回码，线程的信号屏蔽码，线程的优先级等

#### 多线程调试查看线程的命令？

info threads 

#### grep命令的作用？find? whereis?

搜索文本，并把匹配的打印出来

#### gdb常用命令？

r(run)执行程序

start:执行到main函数停住

n(next)下一条指令，不进入函数

s(step)进入函数

c执行到下一个断点停住

q退出调试

b（break)设置断点

info b 删除断点

#### 查看端口号的命令？

netstat -an 显示出电脑中所有被打开的端口列表. netstat -ano 显示出所有占用端口的列表.

#### 进程间通信的方式？管道的介绍？管道破裂的信号？命名管道与匿名管道的名字表现在什么上面的？

#### socket套接字的缺点

#### 6.网络io有哪些，如何使用 ，io复用 （select poll epoll)

io复用的意义: 是用于提升**效率，单**个进程可以同时监听多个网络连接 IO

首先io的几个经典的模型分为阻塞IO， 非阻塞IO， 信号驱动io, 异步IO， 多路转接IO

1.阻塞IO：

发起IO调用，如果IO条件不满足则一直等待，直到条件符合

2.非阻塞IO ：

发起IO调用，如果条件不满足则直接报错返回，执行其他的指令，然后再次发起IO调用，如果条件不满足继续报错返回，直到调用时发现条件满足，之后执行数据拷贝，然后调用返回

3.信号驱动IO ：

自定义IO信号，如果IO条件具备则发送IO信号，收到信号后则打断其他操作进行信号处理，执行IO操作进行数据拷贝，结束后调用返回

4.异步IO：

CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。

在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。

因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。

多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。

由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。

另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。

5.多路IO复用

5.1作用：可以监控多个文件描述符，当文件描述符当中有事件产生的时候，就会通知调用者

select poll epoll

##### select 

```c++
int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);
```

select模型对大量描述符进行几种事件监控，让用户能够仅仅针对事件就绪的描述符进行操作，对就绪事件的判断主要有以下几个标准：
  1、可读事件：接收缓冲区中数据大小大于等于低水位标记（默认一个字节）。
  2、可写事件：发送缓冲区中空闲空间的大小大于等于低水位标记（默认一个字节）。
  3、异常事件：描述符是否发生了某些异常。

1.实际上每个事件都对应一个位图，将某个事件集合中描述符的位置置为1用于标记用户关心该描述符的某些事件

2.将这些集合拷贝到内核空间进行监控，对这个位图中的所有描述符进行遍历判断，判断事件是否就绪

3.如果有某个文件描述符就绪了了用户关心的事件， 则会返回给用户结果，返回的时候分别从各个事件中将没有就绪的文件描述符对应的位置置为0， 返回给用户三个表示就绪文件描述符的集合

4.用户通过遍历拿到的文件描述符集合，来判断哪些文件描述符就绪了哪些事件，之后进行操作

```
//fd_set是一个结构体，结构体内部是一个数组，数组元素是long类型，但是它不是按照数组方式使用的，而是按照位图方式使用的
fd_set readfds;//定义文件描述符集合，这个文件描述符集合的名字叫做readfds
//将文件描述符集合中的全部比特位都置为0
FD_ZERO(&readfds);
//将关心的事件描述符放进事件集合中
FD_SET(0, &readfds);
FD_SET(1, &readfds);
//第一个参数是nfds,是监控的最大文件描述符的数值+1，例如我监控的最大文件描述符是8 ，那nfds就是9
//第二个参数是读事件集合
//第三个参数是写事件集合
//第四个参数是异常事件集合
select(2, &readfds, NULL, NULL, NULL);
```

操作fd_set的接口



#### 7.多线程如何实现同步的

#### 线程池

#### 线程间的通信方式

#### 进程间的通信方式

每创建一个进程，内核中就会有一个task_struct结构体，通过双向链表来组织

**1.管道**：mkfifo/mkfifo函数

**匿名管道**：fd[2]; fd[0] 是读端，fd[1]是写端，匿名管道没有标识符 

管道特性：

1、单双工通信，只能从写端流向读端

2、流式存取，读端可以决定每次读多少个字节

3、管道的生命周期跟随进程

匿名管道只适用于具有亲缘关系的进程，先创建管道， 在创建子进程

管道大小：65536字节，64k

如果进程操纵写端往匿名管道中写的时候，写的字节数量小于4K，则保证当前写入操作的原子性

两种情况：不一定会产生僵尸进程

1.写端描述符设置为非阻塞，读端文件描述符不管

* 读端文件描述符都关闭，调用write的进程会收到管道破裂的信号SIGPIPE，导致当前调用write的进程退出
* 读端文件描述符不关闭，但是也不读，写端一直写。知道写满，则带调用write函数会返回-1，报错，资源不可用

2.将读端文件描述符设置为非阻塞，写端不管

* 读写端文件描述符都关闭，读端一直读，直到将读端的内容读完，再次调用read函数，返回0，表示没有任何内容

* 写端文件描述符不关闭，但是也不写，读端一直读。read函数会返回-1，报错，资源不可用

  

  **命名管道**：也是内核当中开辟的一段缓冲区，这段缓冲区是有标识符，不需要具有亲缘关系，	通过标识符就可以找到，命名管道的生命周期也是跟随进程的



**2.共享内存** ：

创建：int shmget(key_t key, size_t size, int shmflg)返回值返回但是共享内存的操作句柄

附加：int shmat()

分离：shmdt()

操作： shmctl()

进程A的task_struct结构体中有一个内存指针，指向虚拟地址空间，虚拟地址空间是不能实际存储数据的，真正存储数据的是物理地址，通过一个页表结构，将物理地址和虚拟地址映射起来

共享内存原理：实际是在物理内存上开辟一段共享内存，这段共享内存可以被不同的进程附加到自己的共享区，共享内存通过页表映射到进程虚拟地址空间中的共享区，附加的进程通过操作共享区来交换数据

共享内存的标识符和共享内存的操作句柄的区别：例如你要看电视，电视是标识符，遥控器是操作句柄

共享内存的生命周期是跟随操作系统内核的，进程在访问共享内存的时候。是访问不是拿走



**3.消息队列**

1.队列的特性是先进先出，内核中实现消息队列的时候，使用的是链表

2.消息队列的元素是有类型的，每种类型有优先级概念

 消息队列的生命周期也是跟随内核的

**4.信号量**

1.信号量的底层是一个计数器，信号量是用来进程控制的

**5.信号**

信号的概念，信号的产生，信号的注册，信号的注销，信号的捕捉处理，自定义处理信号

信号是一个软件中段

1-31非可靠

34-64可靠，信号是不可能丢失的



# 网络



#### get post  区别

1.url,get的参数url是可见的，post的url参数是不可见的

2.数据传输：get通过拼接url进行传递参数，post通过body体传输参数

3.缓存性：get请求时可以缓存的，但是post请求是不能缓存的

4.传输数据大小：get一般传输的大小不超过2k-4k,post传输的数据大熊啊可以设定的无限大

5.数据包：get是浏览器把header和data一起发送出去，服务器响应200，而post是浏览器先发动heaer，然后服务器响应100，之后浏览器在发送data，服务器响应200

6.安全性 原则上post比get更加安全，因为url是不可见的

#### 请求与响应是哪个协议的？http是哪一层的？TCPIP协议分层有哪几层？有哪些请求方法？

http协议，http协议在应用层,tcp在传输层，ip在网络层

![img](https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180810112625596-2103906128.png)

#### TCP的三次握手与四次挥手的具体内容、拥塞控制的四个算法？

tcp三次握手是由客户端先给服务端发送一个SYN数据包，这是客户端的状态变成了

#### TCP和UDP属于哪一层？IP协议属于哪一层？DNS协议？

tcp，udp在传输层，ip在网络层，dns协议在应用层

网络数据在传输过程中五元组信息，任何一个需要在网络当中传输的数据，都会具有五元组信息，否则网络不会给转发

{源端口，目的端口，源IP，目的IP，协议}



#### 说一下http状态码

1xx  指示信息，表示请求已接收，继续处理

2xx  成功 表示请求已被成功接收，解析，接受

* 200 客户端请求成功
* 201 请求已被成功处理，并且创建了新的资源

3xx  重定向，一般表示要完成请求必须进行更近一步的操作

* 301 永久重定向，表示资源已经永久移动到了另一个位置
* 304 表示客户端可以使用以前请求的结果，不需要再次请求

4xx  客户端错误，一般是请求有语法错误或请求无法实现

* 400 语法无效，服务器无法理解该请求
* 401 请求未经授权

* 403 指的是服务端有能力处理该请求，但是拒绝授权访问
* 404 请求资源不存在，比如资源被删除了，错误的url

5xx  服务器端错误，服务器未能实现合法的请求

* 500 服务器发生了不可预期的错误
* 502 表示作为网关或代理角色的服务器，从上游服务器中接收到的响应是无效的
* 503服务器当前不能处理客户端请求，一段时间后回复正常
* 504 表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应

#### 说一下计算机的补码，为什么会有补码

采用补码可以简化**计算机硬件电路设计的复杂度 **。 对于有符号数，内存要区分符号位和数值位，要是能把符号位和数值位等同起来，让它们一起参与运算，不再加以区分，只用加法器就可以同时实现加法和减法运算，这样硬件电路就变得简单了。

#### 补码是怎么计算的（二进制，八进制，十六进制）

二进制：符号位不变，其余位按位取反后，+1

八进制：

十六进制：FFFF-正数代表的十六进制+1

#### 大小端了解吗，大小端分别在哪里应用 

这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

小端就是：低字节序放在低地址中，高字节序放在高地址中

大端：低字节序放在高地址，高字节序放在低地址

小端字节序通常应用在主机字节序，大端主要应用在网络字节序

¨          #define ntohs(n)     //16位数据类型网络字节顺序到主机字节顺序的转换

¨          #define htons(n)     //16位数据类型主机字节顺序到网络字节顺序的转换

¨          #define ntohl(n)      //32位数据类型网络字节顺序到主机字节顺序的转换

¨          #define htonl(n)      //32位数据类型主机字节顺序到网络字节顺序的转换



#### 在浏览器下输入一个url会发生什么

解析url地址

由DNS协议进行解析，解析出来对应的ip地址

* 解析过程：1.查找浏览器缓存，浏览器一般会缓存DNS记录一段时间，如果有缓存，直接返回ip，没有下一步
* 2.查找系统缓存，在浏览器缓存中找不到ip以后，浏览器会进行系统调用，查找本机的hosts文件，如果找到了，返回Ip,没有下一步
* 3.查找路由器缓存，路由器一般有自己的DNS缓存，将前面的请求发送给路由器，如果查找到了，返回IP没有下一步
* 4.递归查询，上面都没有找到ip的话，lsp的DNS服务器就会进行递归查询（就是如果主机询问的本地域名服务器不知道背查询的域名的ip地址，，那么本地域名服务器以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步查询）
* 5.迭代查询：本地域名服务器向根域名服务器查询一般用的都是迭代查询（就是当根域名服务器收到本地域名服务器发出的查询请求报文后，告诉本地域名服务器下一步应该查询哪一个域名服务器，然后本地域名服务器自己去查询）

ip地址和服务端默认发80端口建立tcp连接，（tcp三次握手）

* tcp三次握手的详细过程

http协议是建立在tcp/ip协议之上的，tcp三次握手建立完成之后，http就可以进行正常的请求和响应了，浏览器通过http协议发送请求

服务端接收请求

服务器响应

tcp断开连接

浏览器解析资源

渲染页面

#### HTTP是位于哪一层的？HTTP方法？PUT方法的作用？POST方法和GET方法的区别？状态码？

#### HTTPS有了解吗？

#### TCP/UDP是哪一层的？DNS是哪一层的？DNS的传输层使用的协议？

#### DNS的工作过程

本地域名服务器

#### TCP的拥塞控制？



## 数据库

#### 安装mariadb

 查看当前机器是否拥有mariadb

```
rpm -qa | grep mariadb
```

![image-20220423131306419](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220423131306419.png)

```
yum list | grep mariadb
```

![image-20220423131654583](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220423131654583.png)

安装

```
yum install mariadb-server
yum install mriadb
yum install mariadb-devel
```

启动

```
service mariadb start
```

停止

```
service mariadb stop
```

重启

```
service mariadb restart
```

mysqld:是mysql的服务端

mysql:是mysql的客户端



##### 1.什么是数据库事务？

答：数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。

##### 数据库如何分页

##### having和where的区别

##### 聚合函数有哪些

##### 哈希索引和B+树索引的特点

##### 2.数据库事务的特性？

答：

![img](https://pic4.zhimg.com/80/v2-f044b82c370387730c75b0cb1eea194b_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-0641544fde1a20d56bf1894c7bb45b29_720w.png)

#####  3.什么是脏读，幻读，不可重复读？

答：

脏读是读到其他事务未提交的数据；

不可重复读指在一个事务中前后读取数据不一致，即读到其他事务已提交的数据，针对update操作；

幻读是指在一个事务中前后读取的数据总量不一致，例如前后行数不同，针对insert操作。

##### 4.事务的隔离级别和四级封锁协议？

答：事务是定义和维护一致性的单位，封锁就是要保证这种一致性。如果对封锁的要求高会增加开销，降低并发性和效率；有的事务并不严格要求结果的质量（如用于统计的事务），如果加上严格的封锁则是不必要和不经济的。因此有必要进行进一步的分析，考察不同级别的一致性对数据库数据的质量及并行能力的影响。

隔离级别：

![img](https://pic2.zhimg.com/80/v2-06dbc6b11312a3959dec8606faf64fa9_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-69609ccc8f589de3b79361c299fdada4_720w.jpg)

四级封锁协议：

一级封锁协议：事务在对需要修改的数据上面（就是在发生修改的瞬间） 对其加共享锁（其他事务不能更改，但是可以读取-导致“脏读”），直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK)。

二级封锁协议是：1）事务 在对需要更新的数据 上（就是发生更新的瞬间） 加 排他锁 （直到事务结束） ， 防止其他事务读取未提交的数据，这样，也就避免了 “脏读” 的情况。2）事务 对当前被读取的数据 上面加共享锁（当读到时加上共享锁），一旦读完该行，立即 释放该 该行的共享锁 - 从数据库的底层实现更深入的来理解，既是，数据库会对游标当前的数据上加共享锁 ， 但是当游标离开当前行的时候，立即释放该行的共享锁。二级封锁协议除防止了“脏读”数据，但是不能避免 丢失更新，不可重复读，幻读 。

三级封锁协议是：二级封锁协议加上事务在读取数据的瞬间必须先对其加共享锁 ，但是直到事务结束才释放 ，这样保证了可重复读（既是其他的事务能读取该数据，但是不能更新该数据）。

四级封锁协议是对三级封锁协议的增强，其实现机制也最为简单，直接对事务中所读取或者 更改的数据所在的表加表锁，也就是说，其他事务不能读写该表中的任何数据。这样所有的 脏读，不可重复读，幻读 ，都得以避免！

##### 6.什么是数据库索引？索引的优缺点？

答：

![img](https://pic4.zhimg.com/80/v2-08ba8058a8d14caf22d617340d979d87_720w.jpg)

索引虽然可以加快搜索速度，但是并不是越多越好。索引文件越大，占用的空间越多，由于索引底层大多是B+树等平衡多叉树，为了维护平衡，增删的时间效率很差。

##### 7.索引的底层数据结构？各自的特点？

答：B树，B+树等。这两种都是平衡多叉树。B树的结点保存索引和关键字，B+树的非叶子结点保存索引，叶子节点保存关键字的有序链表。

![img](https://pic2.zhimg.com/80/v2-90f791a75c9f9dbf91f071caf7651d5d_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-b54d4431355ee2ebc836ac66afde7ba2_720w.jpg)

![img](https://pic4.zhimg.com/80/v2-758cf16b31bfc0b407a480427332ac4f_720w.png)

##### 8.Mysql 中的索引类型和区别？

答：

![img](https://pic1.zhimg.com/80/v2-5bcb9bbed0f9f8ae914385569a809a04_720w.jpg)

##### 9.什么是主键，外键？为什么要有主键？

答:

![img](https://pic2.zhimg.com/80/v2-e95edca0bb9a540407a19ee2d0e05365_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-96256a97a047f7b705517aef96f3b094_720w.jpg)

##### 10.数据库范式

答：为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。

**第一范式(确保每列保持原子性)**

第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。

**第二范式(确保表中的每列都和主键相关)**

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

**第三范式(确保每列都和主键列直接相关,而不是间接相关)**

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）

这样一个表结构，就存在上述关系。 学号--> 所在院校 --> (院校地址，院校电话)

这样的表结构，我们应该拆开来，如下：

（学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）

##### 11.什么是存储过程？

答：存储过程是一组为了完成特定功能的SQL语句集，只需编译一次，用户通过指定存储过程名字和参数来调用，示例如下：EXECUTE AddNewProduct( 'JTS01', 'Stuffed Eiffel Tower', 6.49, 'Plush stuffed toy with' ); 优点： 简单 安全 高性能 缺点：移植性差

##### 12.数据库日志的类型和功能

答： 错误日志、查询日志、慢查询日志、事务日志、二进制日志、中继日志**。**

错误日志：记录mysql实例运行中产生的错误或警告信息，以及每次mysql实例启动和停止的时间，必须开启；

查询日志：记录mysql运行的所有sql操作，无论成功与否；

慢查询日志：记录超过指定时间显示查询结果的sql命令，只会记录执行成功的语句；

二进制日志：记录的是除查询之外的所有命令；

中继日志：连接mastert和slave的信息，它是复制的核心，I/O线程将来自master的事件存储到中继日志中，中继日志充当缓冲，这样master不必等待slave执行完成就可以发送下一个事件；

事务日志：**事务实际上是依靠事务日志实现的**。存储引擎在修改表数据时，只需修改内存拷贝，再把修改行为记录到持久在硬盘上的事务日志中，日志持久化后，内存中修改的数据慢慢刷回磁盘。若在刷回磁盘前系统崩溃，可根据日志恢复。

##### 13.innodb引擎和MyISAM引擎各自的特点和适应场景

答：
Innodb引擎提供了对数据库事务的支持，并且实现了SQL标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。
　　MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。

innodb提供了事务支持，外键支持和行级锁。

innodb更适合插入删除操作多的场景，myisam更适合查询操作更多的场景，MyISAM引擎 常用于读多写少的场景，不支持事务操作，提供表锁，不支持行级锁和外键，可以存储表的行数，一些操作不需要遍历全表，但是写操作会表锁，效率会低一些。但是表损坏后不能数据恢复。

##### 14.什么是乐观锁，悲观锁？

答：

![img](https://pic2.zhimg.com/80/v2-83d9a76716f7f5d4f76045546255800d_720w.jpg)

##### 15.MVCC和乐观锁的区别

答：

![img](https://pic4.zhimg.com/80/v2-9d0d2a7f9a953971ff0afc3d40c33517_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-cc1898ad8f61c9e5b9d85dba0cbb5d88_720w.jpg)

MVCC只用来解决读写冲突，写写冲突是一级封锁协议解决的，而读读无冲突。

![img](https://pic1.zhimg.com/80/v2-42a3f6e3804ed69c3c3a111c6cd19f18_720w.jpg)

![img](https://pic4.zhimg.com/80/v2-7e9811d2c82e50902552f5b2e72f86bb_720w.png)

![img](https://pic2.zhimg.com/80/v2-e8326168fbd4188f1816210376ac1335_720w.jpg)

##### 16.什么是左连接，右连接，内连接

答：

![img](https://pic1.zhimg.com/80/v2-0f8b6e26d4ceb1440fb569922732dc1c_720w.jpg)

##### 17.SQL语句的执行过程

答：数据库引擎检查语法，语义，对查询对象加锁，访问权限核对，确定最佳执行计划。

##### 18.sql查询语句优化，索引优化？

答：sql解析出任务，引擎会对任务进行优化，比如如果当时引擎优化后觉得全表扫描更快，就不会走索引；数据库用直方图对数据的分布进行了统计，它能估计出来走哪个筛选效率更高；在表中建立索引，尽量在where group by字段建索引，尽量避免使用select * 而是使用具体字段，返回无用字段会降低查询效率。建立组合索引遵循最左前缀原则：

![img](https://pic2.zhimg.com/80/v2-1f06920824047c1de39c832dd3a2573d_720w.png)

##### 19.海量数据数据库分库分表

答：分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。因此，我们必须换一种思路，对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库!与分表策略相似，分库可以采用通过一个关键字取模的方式，来对数据访问进行路由。

垂直切分和水平切分

![img](https://pic4.zhimg.com/80/v2-9fd1bbde9092c42b4e0028ec34ff934f_720w.jpg)

原文链接：[大数据高并发之-Mysql分表与分库使用场景以及设计方式_数据库_逍遥游的博客-CSDN博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_36019547/java/article/details/82696210)

##### 20.redis数据库的缓存一致性，缓存击穿，缓存雪崩，缓存并发

答：分布式环境下非常容易出现缓存和数据库间的数据一致性问题，针对这一点的话，只能说，如果你的项目对缓存的要求是强一致性的，那么请不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括 合适的缓存更新策略，更新数据库后要及时更新缓存、缓存失败时增加重试机制，例如MQ模式的消息队列。

缓存击穿问题

缓存击穿表示恶意用户模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在了数据库上，导致数据库异常。这个我们在实际项目就遇到了，有些抢购活动、秒杀活动的接口API被大量的恶意用户刷，导致短时间内数据库宕机了，好在数据库是多主多从的，hold住了。解决：布隆过滤器（推荐）

bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。

缓存雪崩问题

缓存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。

解决方案：

1、也是像解决缓存穿透一样加锁排队，实现同上;

2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;

缓存并发问题

这里的并发指的是多个redis的client同时set key引起的并发问题。比较有效的解决方案就是把redis.set操作放在队列中使其串行化，必须的一个一个执行，具体的代码就不上了，当然加锁也是可以的。

原文链接：[https://cloud.tencent.com/developer/news/243410](https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/news/243410)

##### 21.什么是非关系型数据库nosql(KV数据库：redis memcached，MongoDB)

答：Key-Value存储:(基于Redis)

传统的关系型数据库，处理一对多的问题，需要把外键放在多的一端，因为RDBMS理论中没有集合这个概念。而使用Redis，我们可以在一端来管理一对多的关系，使用Set（集合）。

如果使用MySQL，当数据规模非常大时，上面两个查询操作都需要借助表关联技术，而大表间的join在大型系统中是需要极力避免的操作。相反Redis的每个操作都会局限在一个较小的数据集范围内，而且key-value的存储形式，定位key只是一个复杂度为O(1)的操作。在very huge的数据量下，Redis性能效果非常优异，这就是NoSQL的优势所在！

##### 22.redis数据持久化

答：

Redis是一种高级key-value数据库。它跟memcached类似，不过数据可以持久化，而且支持的数据类型很丰富。有字符串，链表，集 合和有序集合。支持在服务器端计算集合的并，交和补集(difference)等，还支持多种排序功能。所以Redis也可以被看成是一个数据结构服务 器。Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。 由于Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。redis提供两种方式进行持久化，一种是RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是AOF（append only file）持久化（原理是将Reids的操作日志以追加的方式写入文件）。

![img](https://pic1.zhimg.com/80/v2-e29b035c1e753e5c0650d3cbd0763e04_720w.jpg)

原文链接：[https://www.cnblogs.com/chenliangcl/p/7240350.html](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/chenliangcl/p/7240350.html)

##### 23.Mysql和redis的区别

答：

![img](https://pic2.zhimg.com/80/v2-0267dbe64311ead582b3e59fd2404481_720w.jpg)

![img](https://pic1.zhimg.com/80/v2-9daeef8412163f642915c3d2b20631e4_720w.jpg)

Mysql是关系型数据库(表格)，redis是非关系型（K-V）

# 项目

## 力扣项目

#### 在项目中遇到的问题

#### 项目的介绍：实现了哪些功能 每个功能是如何实现的

实现了在浏览器中查看全部试题信息，当我点击一个试题的时候，可以跳转到对应的一个试题，在里面进行代码编写，编写完成以后点击submit提交，提交的代码就会传到服务器中去编译运行，服务器编译运行之后，会将运行的结果返还给浏览器中去显示

具体实现是提供了三个接口分别是get,get,post三个请求



####  为什么选择文件存储题目而不是选择数据库 

其实文件存储还是数据库都是可以的，只不过我这个项目是一个简单的模拟力扣的项目，cpp访问数据库会比较复杂，使用文件存储更加简单方便

#### 为什么使用进程程序替换而不是开辟一个新线程处理？ 

我在编译的时候是用了进程程序替换，将原进程替换成了一个G++进程，用来进行编译，为了保证每个代码都独立的编译，多个请求之间互不影响，所以若干个请求都需要使用G++去替换，如果是多线程的话，他们使用的是一个进程，就会混乱

#### 编译运行好的结果是怎么返回给前端的

用到了httplib中定义好的请求与响应的结构，通过把运行好的结果写入文件，然后再从文件中读取结果的方式

#### json cpp 的作用 ？ 

一个json对象，用来将源代码和测试用例放在一起构成一个结构，提交给编译运行模块

####  boost库用了哪些函数？

使用了split切割函数，用于对题目信息的四元组进行切割，保存在unordered_map中，源码是

```c++
boost::split(std::vector<std::string> type, type, boost::is_any_of(""), boost::token_compress_off);
```



#### 如何获取到用户提交的代码？用的什么请求？

用了http请求

#### 日志是如何实现的？

#### body是如何取出来的？怎么对body体进行解析

#### 试题模块怎么组织的

试题模块用的是unordered_map来进行组织的， 底层是哈希表，无序但是效率高，map的底层是红黑树，它不仅支持有序查询效率也很高，为什么不选择map二选择了unorderen_map是因为服务器可能同时收到很多请求，map会使效率变低

#### urltail这个类的作用

#### 用户写的代码时怎么获取到的

#### 如果用户重复提交相同的代码怎么解决，时间戳也不能区分

#### 用户怎么拿到试题列表，是数据库还是文件

# git/makefile/思维问题

#### 怎么配置sudo,让普通用户在root根目录下创建文件

#### sh登录到一个linux机器，怎么实现免密登录

#### git push 以后怎么撤销

#### 8G排序

8G的数据存储在磁盘上 需要排序，内存只有 2G，如何对这8G的数据进行排序？

归并

8G -> 8个1G的文件，1G的内容进行排序 -> 8次

8 - 4 - 2 - 1

####  合并K个升序链表

#### 如何用rand7实现rand10

#### 在一个文本里搜索某个关键字出现的频率

#### 在makefile中如何使用户名和密码隐藏

#### 如果每个人都要做很多任务，有的deadline非常紧急，你会如何做

#### 对于每天做重复性工作的看法

#### 除了c++还会什么语言吗

#### 输出一个数组中第二大的数，针对于上面那个题目设计测试用例

#### N路归并排序

#### LRU机制

#### 怎么将test软链接到temp

#### Nginx配置文件

#### git的作用

#### 设计模式

 